<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DataFramesMeta Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFramesMeta.jl/stable/api/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFramesMeta Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../dplyr/">Tutorial for coming from dplyr</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/master/docs/src/api/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.printlabels" href="#DataFramesMeta.printlabels"><code>DataFramesMeta.printlabels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">printlabels(df, [cols=All()]; unlabelled = true)</code></pre><p>Pretty-print all labels in a data frame.</p><p><strong>Arguments</strong></p><ul><li><p><code>cols</code>: Optional argument to select columns to print. Can be any valid multi-column selector, such as <code>Not(...)</code>, <code>Between(...)</code>, or a regular expression.</p></li><li><p><code>unlabelled</code>: Keyword argument for whether to print the columns without user-defined labels. Deftaults to <code>true</code>. For column <code>col</code> without a user-defined label, <code>label(df, col)</code> returns the name of the column, <code>col</code>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(wage = [12], age = [23]);

julia&gt; @label! df :wage = &quot;Hourly wage (2015 USD)&quot;;

julia&gt; printlabels(df)
┌────────┬────────────────────────┐
│ Column │                  Label │
├────────┼────────────────────────┤
│   wage │ Hourly wage (2015 USD) │
│    age │                    age │
└────────┴────────────────────────┘

julia&gt; printlabels(df, :wage)
┌────────┬────────────────────────┐
│ Column │                  Label │
├────────┼────────────────────────┤
│   wage │ Hourly wage (2015 USD) │
└────────┴────────────────────────┘

julia&gt; printlabels(df; unlabelled = false)
┌────────┬────────────────────────┐
│ Column │                  Label │
├────────┼────────────────────────┤
│   wage │ Hourly wage (2015 USD) │
└────────┴────────────────────────┘

julia&gt; printlabels(df, r&quot;^wage&quot;)
┌────────┬────────────────────────┐
│ Column │                  Label │
├────────┼────────────────────────┤
│   wage │ Hourly wage (2015 USD) │
└────────┴────────────────────────┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/metadata.jl#L152-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.printnotes" href="#DataFramesMeta.printnotes"><code>DataFramesMeta.printnotes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">printnotes(df, cols = All(); unnoted = false)</code></pre><p>Print the notes and labels in a data frame.</p><p><strong>Arguments</strong></p><ul><li><code>cols</code>: Optional argument to select columns to print. Can be any valid multi-column selector, such as <code>Not(...)</code>, <code>Between(...)</code>, or a regular expression.</li><li><code>unnoted</code>: Keyword argument for whether to print the columns without user-defined notes or labels.</li></ul><p>For the purposes of printing, column labels are printed in addition to notes. However column labels are not returned by <code>note(df, col)</code>.</p><pre><code class="nohighlight hljs">julia&gt; df = DataFrame(wage = [12], age = [23]);

julia&gt; @label! df :age = &quot;Age (years)&quot;;

julia&gt; @note! df :wage = &quot;Derived from American Community Survey&quot;;

julia&gt; @note! df :wage = &quot;Missing values imputed as 0 wage&quot;;

julia&gt; @label! df :wage = &quot;Hourly wage (2015 USD)&quot;;

julia&gt; printnotes(df)
Column: wage
────────────
Label: Hourly wage (2015 USD)
Derived from American Community Survey
Missing values imputed as 0 wage

Column: age
───────────
Label: Age (years)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/metadata.jl#L225-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@astable-Tuple" href="#DataFramesMeta.@astable-Tuple"><code>DataFramesMeta.@astable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@astable(args...)</code></pre><p>Return a <code>NamedTuple</code> from a single transformation inside the DataFramesMeta.jl macros, <code>@select</code>, <code>@transform</code>, and their mutating and row-wise equivalents.</p><p><code>@astable</code> acts on a single block. It works through all top-level expressions and collects all such expressions of the form <code>:y = ...</code> or <code>$y = ...</code>, i.e. assignments to a <code>Symbol</code> or an escaped column identifier, which is a syntax error outside of DataFramesMeta.jl macros. At the end of the expression, all assignments are collected into a <code>NamedTuple</code> to be used with the <code>AsTable</code> destination in the DataFrames.jl transformation mini-language.</p><p>Concretely, the expressions</p><pre><code class="nohighlight hljs">df = DataFrame(a = 1)

@rtransform df @astable begin
    :x = 1
    y = 50
    :z = :x + y + :a
end</code></pre><p>become the pair</p><pre><code class="nohighlight hljs">function f(a)
    x_t = 1
    y = 50
    z_t = x_t + y + a

    (; x = x_t, z = z_t)
end

transform(df, [:a] =&gt; ByRow(f) =&gt; AsTable)</code></pre><p><code>@astable</code> has two major advantages at the cost of increasing complexity. First, <code>@astable</code> makes it easy to create multiple columns from a single transformation, which share a scope. For example, <code>@astable</code> allows for the following (where <code>:x</code> and <code>:x_2</code> exist in the data frame already).</p><pre><code class="nohighlight hljs">@transform df @astable begin
    m = mean(:x)
    :x_demeaned = :x .- m
    :x2_demeaned = :x2 .- m
end</code></pre><p>The creation of <code>:x_demeaned</code> and <code>:x2_demeaned</code> both share the variable <code>m</code>, which does not need to be calculated twice.</p><p>Second, <code>@astable</code> is useful when performing intermediate calculations and storing their results in new columns. For example, the following fails.</p><pre><code class="nohighlight hljs">@rtransform df begin
    :new_col_1 = :x + :y
    :new_col_2 = :new_col_1 + :z
end</code></pre><p>This because DataFrames.jl does not guarantee sequential evaluation of transformations. <code>@astable</code> solves this problem</p><p>@rtransform df @astable begin     :new<em>col</em>1 = :x + :y     :new<em>col</em>2 = :new<em>col</em>1 + :z end</p><p>Column assignment in <code>@astable</code> follows similar rules as column assignment in other DataFramesMeta.jl macros. The left- -hand-side of a column assignment can be either a <code>Symbol</code> or any expression which evaluates to a <code>Symbol</code> or <code>AbstractString</code>. For example <code>:y = ...</code>, and <code>$y = ...</code> are both valid ways of assigning a new column. However unlike other DataFramesMeta.jl macros, multi-column assignments via <code>AsTable</code> are disallowed. The following will fail.</p><pre><code class="nohighlight hljs">@transform df @astable begin
    AsTable = :x
end</code></pre><p>References to existing columns also follow the same rules as other DataFramesMeta.jl macros.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; df = DataFrame(a = [1, 2, 3], b = [4, 5, 6]);

julia&gt; d = @rtransform df @astable begin
           :x = 1
           y = 5
           :z = :x + y
       end
3×4 DataFrame
 Row │ a      b      x      z
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      4      1      6
   2 │     2      5      1      6
   3 │     3      6      1      6

julia&gt; df = DataFrame(a = [1, 1, 2, 2], b = [5, 6, 70, 80]);

julia&gt; @by df :a @astable begin
            ex = extrema(:b)
            :min_b = first(ex)
            :max_b = last(ex)
       end
2×3 DataFrame
 Row │ a      min_b  max_b
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      5      6
   2 │     2     70     80

julia&gt; new_col = &quot;New Column&quot;;

julia&gt; @rtransform df @astable begin
           f_a = first(:a)
           $new_col = :a + :b + f_a
           :y = :a * :b
       end
4×4 DataFrame
 Row │ a      b      New Column  y
     │ Int64  Int64  Int64       Int64
─────┼─────────────────────────────────
   1 │     1      5           7      5
   2 │     1      6           8      6
   3 │     2     70          74    140
   4 │     2     80          84    160</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L358-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@based_on-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@based_on-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@based_on</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@based_on(d, args...)</code></pre><p>Deprecated version of <code>@combine</code>, see: <a href="#DataFramesMeta.@combine-Tuple{Any, Vararg{Any}}"><code>@combine</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2268-L2272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@by-Tuple{Any, Any, Vararg{Any}}" href="#DataFramesMeta.@by-Tuple{Any, Any, Vararg{Any}}"><code>DataFramesMeta.@by</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@by(d::AbstractDataFrame, cols, e...; kwargs...)</code></pre><p>Split-apply-combine in one step.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>cols</code> : a column indicator (Symbol, Int, Vector{Symbol}, etc.)</li><li><code>e</code> :  keyword-like arguments, of the form <code>:y = f(:x)</code> specifying</li></ul><p>new columns in terms of column groupings</p><ul><li><code>kwargs</code> : keyword arguments passed to <code>DataFrames.combine</code></li></ul><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code> or a <code>GroupedDataFrame</code></li></ul><p><strong>Details</strong></p><p>Transformation inputs to <code>@by</code> can come in two formats: a <code>begin ... end</code> block, in which case each line in the block is a separate transformation, or as a series of keyword-like arguments. For example, the following are equivalent:</p><pre><code class="nohighlight hljs">@by df :g begin
    :mx = mean(:x)
    :sx = std(:x)
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@by(df, :g, mx = mean(:x), sx = std(:x))</code></pre><p>Transformations can also use the macro-flag <a href="#DataFramesMeta.@astable-Tuple"><code>@astable</code></a> for creating multiple new columns at once and letting transformations share the same name-space. See <code>? @astable</code> for more details.</p><p><code>@by</code> accepts the same keyword arguments as <code>DataFrames.combine</code> and can be added in two ways. When inputs are given as multiple arguments, they are added at the end after a semi-colon <code>;</code>, as in</p><pre><code class="nohighlight hljs">@by(ds, :g, :x = first(:a); ungroup = false)</code></pre><p>When inputs are given in &quot;block&quot; format, the last lines may be written <code>@kwarg key = value</code>, which indicates keyword arguments to be passed to <code>combine</code> function.</p><pre><code class="nohighlight hljs">@by df :a begin
    :x = first(:a)
    @kwarg ungroup = false
end</code></pre><p>Though <code>@by</code> performs both <code>groupby</code> and <code>combine</code>, <code>@by</code> only forwards keyword arguments to <code>combine</code>, and not <code>groupby</code>. To pass keyword arguments to <code>groupby</code>, perform the <code>groupby</code> and <code>@combine</code> steps separately.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFramesMeta, Statistics

julia&gt; df = DataFrame(
            a = repeat(1:4, outer = 2),
            b = repeat(2:-1:1, outer = 4),
            c = 1:8);

julia&gt; @by(df, :a, :d = sum(:c))
4×2 DataFrame
 Row │ a      d
     │ Int64  Int64
─────┼──────────────
   1 │     1      6
   2 │     2      8
   3 │     3     10
   4 │     4     12

julia&gt; @by df :a begin
           :d = 2 * :c
       end
8×2 DataFrame
 Row │ a      d
     │ Int64  Int64
─────┼──────────────
   1 │     1      2
   2 │     1     10
   3 │     2      4
   4 │     2     12
   5 │     3      6
   6 │     3     14
   7 │     4      8
   8 │     4     16

julia&gt; @by(df, :a, :c_sum = sum(:c), :c_mean = mean(:c))
4×3 DataFrame
 Row │ a      c_sum  c_mean
     │ Int64  Int64  Float64
─────┼───────────────────────
   1 │     1      6      3.0
   2 │     2      8      4.0
   3 │     3     10      5.0
   4 │     4     12      6.0

julia&gt; @by df :a begin
           :c = :c
           :c_mean = mean(:c)
       end
8×3 DataFrame
 Row │ a      c      c_mean
     │ Int64  Int64  Float64
─────┼───────────────────────
   1 │     1      1      3.0
   2 │     1      5      3.0
   3 │     2      2      4.0
   4 │     2      6      4.0
   5 │     3      3      5.0
   6 │     3      7      5.0
   7 │     4      4      6.0
   8 │     4      8      6.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2302-L2427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@byrow-Tuple" href="#DataFramesMeta.@byrow-Tuple"><code>DataFramesMeta.@byrow</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@byrow</code></pre><p>Broadcast operations within DataFramesMeta.jl macros.</p><p><code>@byrow</code> is not a &quot;real&quot; Julia macro but rather serves as a &quot;flag&quot; to indicate that the anonymous function created by DataFramesMeta to represent an operation should be applied &quot;by-row&quot;.</p><p>If an expression starts with <code>@byrow</code>, either of the form <code>@byrow :y = f(:x)</code> in transformations or <code>@byrow f(:x)</code> in <code>@orderby</code>, <code>@subset</code>, and <code>@with</code>, then the anonymous function created by DataFramesMeta is wrapped in the <code>DataFrames.ByRow</code> function wrapper, which broadcasts the function so that it run on each row.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; df = DataFrame(a = [1, 2, 3, 4], b = [5, 6, 7, 8]);

julia&gt; @transform(df, @byrow :c = :a * :b)
4×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      5      5
   2 │     2      6     12
   3 │     3      7     21
   4 │     4      8     32

julia&gt; @subset(df, @byrow :a == 1 ? true : false)
1×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      5</code></pre><p>To avoid writing <code>@byrow</code> multiple times when performing multiple operations, it is allowed to use <code>@byrow</code> at the beginning of a block of operations. All transformations in the block will operate by row.</p><pre><code class="language-julia hljs">julia&gt; @subset df @byrow begin
           :a &gt; 1
           :b &lt; 5
       end
1×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     2      4</code></pre><p><strong>Comparison with <code>@eachrow</code></strong></p><p>To re-cap, the <code>@eachrow</code> macro roughly transforms</p><pre><code class="language-julia hljs">@eachrow df begin
    :a * :b
end</code></pre><p>to</p><pre><code class="language-julia hljs">begin
    function tempfun(a, b)
        for i in eachindex(a)
            a[i] * b[i]
        end
    end
    tempfun(df.a, df.b)
    df
end</code></pre><p>The function <code>*</code> is applied by-row. But the result of those operations is not stored anywhere, as with <code>for</code>-loops in Base Julia. Rather, <code>@eachrow</code> and <code>@eachrow!</code> return data frames.</p><p>Now consider <code>@byrow</code>. <code>@byrow</code> transforms</p><pre><code class="language-julia hljs">@with df @byrow begin
    :a * :b
end</code></pre><p>to</p><pre><code class="language-julia hljs">tempfun(a, b) = a * b
tempfun.(df.a, df.b)</code></pre><p>In contrast to <code>@eachrow</code>, <code>@with</code> combined with <code>@byrow</code> returns a vector of the broadcasted multiplication and not a data frame.</p><p>Additionally, transformations applied using <code>@eachrow!</code> modify the input data frame. On the contrary, <code>@byrow</code> does not update columns.</p><pre><code class="language-julia hljs">julia&gt; df = DataFrame(a = [1, 2], b = [3, 4]);

julia&gt; @with df @byrow begin
           :a = 500
       end
2-element Vector{Int64}:
 500
 500

julia&gt; df
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4</code></pre><p><strong>Comparison with <code>@.</code> and Base broadcasting</strong></p><p>Base Julia provides the broadcasting macro <code>@.</code> and in many cases <code>@.</code> and <code>@byrow</code> will give equivalent results. But there are important deviations in behavior. Consider the setup</p><pre><code class="language-julia hljs">df = DataFrame(a = [1, 2], b = [3, 4])</code></pre><ul><li>Control flow. <code>@byrow</code> allows for operations of the form <code>if ... else</code> and <code>a ? b : c</code> to be applied by row. These expressions cannot be broadcasted in Base Julia. <code>@byrow</code> also allows for expressions of the form <code>a &amp;&amp; b</code> and <code>a || b</code> to be applied by row, something that is not possible in Julia versions below 1.7.</li></ul><pre><code class="nohighlight hljs">julia&gt; @with df @byrow begin
           if :a == 1
               5
           else
               10
           end
       end
2-element Vector{Int64}:
  5
 10

julia&gt; @with df @. begin
           if :a == 1
               5
           else
               10
           end
       end # will error</code></pre><ul><li>Broadcasting objects that are not columns. <code>@byrow</code> constructs an anonymous function which accepts only the columns of the input data frame and broadcasts that function. Consequently, it does not broadcast referenced objects which are not columns.</li></ul><pre><code class="language-julia hljs">julia&gt; df = DataFrame(a = [1, 2], b = [3, 4]);
julia&gt; @with df @byrow :x + [5, 6]</code></pre><p>will error, because the <code>:x</code> in the above expression refers   to a scalar <code>Int</code>, and you cannot do <code>1 + [5, 6]</code>.</p><p>On the other hand</p><pre><code class="language-julia hljs">@with df @. :x + [5, 6]</code></pre><p>will succeed, as <code>df.x</code> is a 2-element vector as is <code>[5, 6]</code>.</p><p>Because <code>ByRow</code> inside <code>transform</code> blocks does not internally   use broadcasting in all circumstances, in the rare instance   that a column in a data frame is a custom vector type that   implements custom broadcasting, this custom behavior will   not be called with <code>@byrow</code>.</p><ul><li>Broadcasting expensive calls. In Base Julia, broadcasting evaluates calls first and then broadcasts the result. Because <code>@byrow</code> constructs an anonymous function and evaluates that function for every row in the data frame, expensive functions will be evaluated many times.</li></ul><pre><code class="language-julia hljs">julia&gt; function expensive()
           sleep(.5)
           return 1
       end;

julia&gt; @time @with df @byrow :a + expensive();
  1.037073 seconds (51.67 k allocations: 3.035 MiB, 3.19% compilation time)

julia&gt; @time @with df :a .+ expensive();
  0.539900 seconds (110.67 k allocations: 6.525 MiB, 7.05% compilation time)
</code></pre><p>This problem comes up when using the <code>@.</code> macro as well,   but can easily be fixed with <code>$</code>. Because <code>$</code> is currently   reserved for escaping column references, no solution currently exists with   <code>@byrow</code> or in DataFramesMeta.jl at large. The best solution is simply</p><pre><code class="nohighlight hljs">@with df begin
    x = expensive()
    :a + x
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L63-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@combine-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@combine-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@combine</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@combine(x, args...; kwargs...)</code></pre><p>Summarize a grouping operation</p><p><strong>Arguments</strong></p><ul><li><code>x</code> : a <code>GroupedDataFrame</code> or <code>AbstractDataFrame</code></li><li><code>args...</code> : transformations defining new columns, of the form <code>:y = f(:x)</code></li><li><code>kwargs</code>: : keyword arguments passed to <code>DataFrames.combine</code></li></ul><p><strong>Results</strong></p><ul><li>A <code>DataFrame</code> or a <code>GroupedDataFrame</code></li></ul><p><strong>Details</strong></p><p>Inputs to <code>@combine</code> can come in two formats: a <code>begin ... end</code> block, in which case each line in the block is a separate transformation, or as a series of keyword-like arguments. For example, the following are equivalent:</p><pre><code class="nohighlight hljs">@combine df begin
    :mx = mean(:x)
    :sx = std(:x)
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@combine(df, :mx = mean(:x), :sx = std(:x))</code></pre><p>Transformations can also use the macro-flag <a href="#DataFramesMeta.@astable-Tuple"><code>@astable</code></a> for creating multiple new columns at once and letting transformations share the same name-space. See <code>? @astable</code> for more details.</p><p><code>@combine</code> accepts the same keyword arguments as <code>DataFrames.combine</code> and can be added in two ways. When inputs are given as multiple arguments, they are added at the end after a semi-colon <code>;</code>, as in</p><pre><code class="nohighlight hljs">@combine(gd, :x = first(:a); ungroup = false)</code></pre><p>When inputs are given in &quot;block&quot; format, the last lines may be written <code>@kwarg key = value</code>, which indicates keyword arguments to be passed to <code>combine</code> function.</p><pre><code class="nohighlight hljs">@combine gd begin
    :x = first(:a)
    @kwarg ungroup = false
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFramesMeta

julia&gt; d = DataFrame(
            n = 1:20,
            x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);

julia&gt; g = groupby(d, :x);

julia&gt; @combine(g, :nsum = sum(:n))
3×2 DataFrame
 Row │ x      nsum
     │ Int64  Int64
─────┼──────────────
   1 │     1     99
   2 │     2     84
   3 │     3     27

julia&gt; @combine g begin
           :x2 = 2 * :x
           :nsum = sum(:n)
       end
20×3 DataFrame
 Row │ x      x2     nsum
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2     99
   2 │     1      2     99
   3 │     1      2     99
   4 │     1      2     99
   5 │     1      2     99
   6 │     1      2     99
   7 │     1      2     99
   8 │     1      2     99
   9 │     1      2     99
  10 │     2      4     84
  11 │     2      4     84
  12 │     2      4     84
  13 │     2      4     84
  14 │     2      4     84
  15 │     2      4     84
  16 │     3      6     27
  17 │     3      6     27
  18 │     3      6     27
  19 │     3      6     27
  20 │     3      6     27
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2157-L2262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@distinct!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@distinct!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@distinct!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@distinct!(d, args...)</code></pre><p>In-place selection of unique rows in an <code>AbstractDataFrame</code>. Users should note that <code>@distinct!</code> differs from <code>unique!</code> in DataFrames.jl, such that <code>@distinct!(df, [:x,:y])</code> is not equal to <code>unique(df, [:x,:y])</code>.  See  <strong>Details</strong> for a discussion of these differences.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>args...</code> :   transformations of the form <code>:x</code> designating</li></ul><p>symbols to specify columns or <code>f(:x)</code> specifying their transformations </p><p><strong>Returns</strong></p><ul><li><code>::AbstractDataFrame</code></li></ul><p>Inputs to <code>@distinct!</code> can come in two formats: a <code>begin ... end</code> block, or as a series of arguments and keyword-like arguments. For example, the following are equivalent:</p><pre><code class="language-julia hljs">@distinct! df begin 
    :x .+ :y
end</code></pre><p>and </p><pre><code class="nohighlight hljs">@distinct!(df, :x .+ :y)</code></pre><p><code>@distinct!</code> uses the syntax <code>@byrow</code> to wrap transformations in the <code>ByRow</code> function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. <code>@distinct!</code> allows <code>@byrow</code> at the beginning of a block of  selections (i.e. <code>@byrow begin... end</code>). The transformation in the block  will operate by row. For example, the following two statements are equivalent.</p><pre><code class="nohighlight hljs">@distinct! df @byrow begin 
    :x + :y
    :z + :t
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@distinct! df begin 
    @byrow :x + :y
    @byrow :z + :t
end
</code></pre><p><strong>Details</strong></p><p>The implementation of <code>@distinct!</code> differs from the <code>unique</code> function in DataFrames.jl.  When <code>args</code> are present, <code>@distinct!</code> relies upon an internal <code>select</code> call which produces  an intermediate data frame containing columns of <code>df</code> specified by <code>args</code>. The unique rows of <code>df</code> are thus determined by this intermediate data frame. This focus on <code>select</code> allows  for multiple arguments to be conveniently passed in the form of column names or transformations.</p><p>Users should be cautious when passing function arguments as vectors. E.g., <code>@distinct(df, $[:x,:y])</code> should be used instead of <code>@distinct(df, [:x,:y])</code> to avoid unexpected behaviors.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFramesMeta;

julia&gt; df = DataFrame(x = 1:10, y = 10:-1:1);

julia&gt; @distinct!(df, :x .+ :y)
1×2 DataFrame
 Row │ x      y      
     │ Int64  Int64  
─────┼───────────────
   1 │     1      10   

julia&gt; @distinct! df begin
            :x .+ :y
        end
1×2 DataFrame
 Row │ x      y      
     │ Int64  Int64  
─────┼───────────────
   1 │     1      10   </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2627-L2720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@distinct-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@distinct-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@distinct</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@distinct(d, args...)</code></pre><p>Return the first occurrence of unique rows in an <code>AbstractDataFrame</code> according  to given combinations of values in selected columns or their transformation.  <code>args</code> can be most column selectors or transformation accepted by <code>select</code>.  Users should note that <code>@distinct</code> differs from <code>unique</code> in DataFrames.jl, such that <code>@distinct(df, :x,:y)</code> is not the same as <code>unique(df, [:x,:y])</code>.  See  <strong>Details</strong> for a discussion of these differences.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>args...</code> :  transformations of the form <code>:x</code> designating</li></ul><p>symbols to specify columns or <code>f(:x)</code> specifying their transformations </p><p><strong>Returns</strong></p><ul><li><code>::AbstractDataFrame</code></li></ul><p>Inputs to <code>@distinct</code> can come in two formats: a <code>begin ... end</code> block, or as a series of arguments and keyword-like arguments. For example, the following are equivalent:</p><pre><code class="language-julia hljs">@distinct df begin 
    :x + :y
end</code></pre><p>and </p><pre><code class="nohighlight hljs">@distinct(df, :x + :y)</code></pre><p><code>@distinct</code> uses the syntax <code>@byrow</code> to wrap transformations in the <code>ByRow</code>  function wrapper from DataFrames, apply a function row-wise, similar to  broadcasting. <code>@distinct</code> allows <code>@byrow</code> at the beginning of a block of  selections (i.e. <code>@byrow begin... end</code>). The transformation in the block  will operate by row. For example, the following two statements are equivalent.</p><pre><code class="nohighlight hljs">@distinct df @byrow begin 
    :x + :y
    :z + :t
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@distinct df begin 
    @byrow :x + :y
    @byrow :z + :t
end</code></pre><p><strong>Details</strong></p><p>The implementation of <code>@distinct</code> differs from the <code>unique</code> function in DataFrames.jl.  When <code>args</code> are present, <code>@distinct</code> relies upon an internal <code>select</code> call which produces  an intermediate data frame containing columns of <code>df</code> specified by <code>args</code>. The unique rows of <code>df</code> are thus determined by this intermediate data frame. This focus on <code>select</code> allows  for multiple arguments to be passed conveniently in the form of column names or transformations.</p><p>Users should be cautious when passing function arguments as vectors. E.g., <code>@distinct(df, $[:x,:y])</code> should be used instead of <code>@distinct(df, [:x,:y])</code> to avoid unexpected behaviors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta;

julia&gt; df = DataFrame(x = 1:10, y = 10:-1:1);

julia&gt; @distinct(df, :x .+ :y)
1×2 DataFrame
 Row │ x      y      
     │ Int64  Int64  
─────┼───────────────
   1 │     1      10   

julia&gt; @distinct df begin
            :x .+ :y
        end
1×2 DataFrame
 Row │ x      y      
     │ Int64  Int64  
─────┼───────────────
   1 │     1      10   </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2460-L2554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@eachrow!-Tuple{Any, Any}" href="#DataFramesMeta.@eachrow!-Tuple{Any, Any}"><code>DataFramesMeta.@eachrow!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@eachrow!(df, body)</code></pre><p>Act on each row of a data frame in-place, similar to</p><pre><code class="nohighlight hljs">for row in eachrow(df)
    ... # Actions that modify `df`.
end</code></pre><p>Includes support for control flow and <code>begin end</code> blocks. Since the &quot;environment&quot; induced by <code>@eachrow! df</code> is implicitly a single row of <code>df</code>, use regular operators and comparisons instead of their elementwise counterparts as in <code>@with</code>. Note that the scope within <code>@eachrow!</code> is a hard scope.</p><p><code>eachrow!</code> also supports special syntax for allocating new columns. The syntax <code>@newcol x::Vector{Int}</code> allocates a new uninitialized column <code>:x</code> with an <code>Vector</code> container with eltype <code>Int</code>.This feature makes it easier to use <code>eachrow</code> for data transformations. <code>_N</code> is introduced to represent the number of rows in the data frame, <code>_DF</code> represents the <code>dataframe</code> including added columns, and <code>row</code> represents the index of the current row.</p><p>Changes to the rows directly affect <code>df</code>. The operation will modify the data frame in place. See <a href="#DataFramesMeta.@eachrow-Tuple{Any, Any}"><code>@eachrow</code></a> which employs the same syntax but allocates a fresh data frame.</p><p>Like with <code>@transform!</code>, <code>@eachrow!</code> supports the use of <code>$</code> to work with column names stored as variables. Using <code>$</code> with a multi-column selector, such as a <code>Vector</code> of <code>Symbol</code>s, is currently unsupported.</p><p><code>@eachrow!</code> is a thin wrapper around a <code>for</code>-loop. As a consequence, inside an <code>@eachrow!</code> block, the reserved-word arguments <code>break</code> and <code>continue</code> function the same as if written in a <code>for</code> loop. Rows unaffected by <code>break</code> and <code>continue</code> are unmodified, but are still present in modified. Also because <code>@eachrow!</code> is a <code>for</code>-loop, re-assigning global variables inside an <code>@eachrow</code> block is discouraged.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code></li><li><code>expr</code> : expression operated on row by row</li></ul><p><strong>Returns</strong></p><p>The modified <code>AbstractDataFrame</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(A = 1:3, B = [2, 1, 2]);

julia&gt; let x = 0
            @eachrow! df begin
                if :A + :B == 3
                    x += 1
                end
            end  #  This doesn&#39;t work without the let
            x
        end
2

julia&gt; df2 = copy(df);

julia&gt; @eachrow! df2 begin
           if :A &gt; :B
               :A = 0
           end
       end;

julia&gt; df2
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      2
   2 │     0      1
   3 │     0      2

julia&gt; df2 = copy(df);

julia&gt; @eachrow! df2 begin
           @newcol :colX::Vector{Float64}
           :colX = :B == 2 ? pi * :A : :B
       end
3×3 DataFrame
 Row │ A      B      colX
     │ Int64  Int64  Float64
─────┼───────────────────────
   1 │     1      2  3.14159
   2 │     2      1  1.0
   3 │     3      2  9.42478

julia&gt; varA = :A; varB = :B;

julia&gt; df2 = copy(df);

julia&gt; @eachrow! df2 begin
           @newcol :colX::Vector{Float64}
           :colX = $varB == 2 ? pi * $varA : $varB
       end
3×3 DataFrame
 Row │ A      B      colX
     │ Int64  Int64  Float64
─────┼───────────────────────
   1 │     1      2  3.14159
   2 │     2      1  1.0
   3 │     3      2  9.42478

julia&gt; x = [1, 1, 1];

julia&gt; @eachrow! df begin
           x[row] = :A
       end;

julia&gt; x
3-element Vector{Int64}:
 1
 2
 3

julia&gt; @eachrow! df begin
           @newcol :m::Vector{Float64}
           :m = mean(_DF[:, row])
       end
3×3 DataFrame
 Row │ A      B      m
     │ Int64  Int64  Float64
─────┼───────────────────────
   1 │     1      2  2.0
   2 │     2      1  1.66667
   3 │     3      2  1.22222

julia&gt; @eachrow! df begin
           :A == 2 &amp;&amp; continue
           println(:A)
       end;
1
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/eachrow.jl#L235-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@eachrow-Tuple{Any, Any}" href="#DataFramesMeta.@eachrow-Tuple{Any, Any}"><code>DataFramesMeta.@eachrow</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@eachrow(df, body)</code></pre><p>Act on each row of a data frame, producing a new dataframe. Similar to</p><pre><code class="nohighlight hljs">for row in eachrow(copy(df))
    ...
end</code></pre><p>Includes support for control flow and <code>begin end</code> blocks. Since the &quot;environment&quot; induced by <code>@eachrow df</code> is implicitly a single row of <code>df</code>, use regular operators and comparisons instead of their elementwise counterparts as in <code>@with</code>. Note that the scope within <code>@eachrow</code> is a hard scope.</p><p><code>eachrow</code> also supports special syntax for allocating new columns. The syntax <code>@newcol x::Vector{Int}</code> allocates a new uninitialized column <code>:x</code> with an <code>Vector</code> container with eltype <code>Int</code>.This feature makes it easier to use <code>eachrow</code> for data transformations. <code>_N</code> is introduced to represent the number of rows in the data frame, <code>_DF</code> represents the <code>DataFrame</code> including added columns, and <code>row</code> represents the index of the current row.</p><p>Changes to the rows do not affect <code>df</code> but instead a freshly allocated data frame is returned by <code>@eachrow</code>. Also note that the returned data frame does not share columns with <code>df</code>. See <a href="#DataFramesMeta.@eachrow!-Tuple{Any, Any}"><code>@eachrow!</code></a> which employs the same syntax but modifies the data frame in-place.</p><p>Like with <code>@transform</code>, <code>@eachrow</code> supports the use of <code>$</code> to work with column names stored as variables. Using <code>$</code> with a multi-column selector, such as a <code>Vector</code> of <code>Symbol</code>s, is currently unsupported.</p><p><code>@eachrow</code> is a thin wrapper around a <code>for</code>-loop. As a consequence, inside an <code>@eachrow</code> block, the reserved-word arguments <code>break</code> and <code>continue</code> function the same as if written in a <code>for</code> loop. Rows unaffected by <code>break</code> and <code>continue</code> are unmodified, but are still present in the returned data frame. Also because <code>@eachrow</code> is a <code>for</code>-loop, re-assigning global variables inside an <code>@eachrow</code> block is discouraged.</p><p><strong>Arguments</strong></p><ul><li><code>df</code> : an <code>AbstractDataFrame</code></li><li><code>expr</code> : expression operated on row by row</li></ul><p><strong>Returns</strong></p><p>The modified <code>AbstractDataFrame</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(A = 1:3, B = [2, 1, 2]);

julia&gt; let x = 0
            @eachrow df begin
                if :A + :B == 3
                    x += 1
                end
            end  #  This doesn&#39;t work without the let
            x
        end
2

julia&gt; @eachrow df begin
            if :A &gt; :B
                :A = 0
            end
        end
3×2 DataFrame
 Row │ A      B
     │ Int64  Int64
─────┼──────────────
   1 │     1      2
   2 │     0      1
   3 │     0      2

julia&gt; df2 = @eachrow df begin
           @newcol :colX::Vector{Float64}
           :colX = :B == 2 ? pi * :A : :B
       end
3×3 DataFrame
 Row │ A      B      colX
     │ Int64  Int64  Float64
─────┼───────────────────────
   1 │     1      2  3.14159
   2 │     2      1  1.0
   3 │     3      2  9.42478

julia&gt; varA = :A; varB = :B;

julia&gt; df2 = @eachrow df begin
           @newcol :colX::Vector{Float64}
           :colX = $varB == 2 ? pi * $varA : $varB
       end
3×3 DataFrame
 Row │ A      B      colX
     │ Int64  Int64  Float64
─────┼───────────────────────
   1 │     1      2  3.14159
   2 │     2      1  1.0
   3 │     3      2  9.42478

julia&gt; x = [1, 1, 1];

julia&gt; @eachrow df begin
           x[row] = :A
       end;

julia&gt; x
3-element Vector{Int64}:
 1
 2
 3

julia&gt; @eachrow df begin
           @newcol :m::Vector{Float64}
           :m = mean(_DF[:, row])
       end
3×3 DataFrame
 Row │ A      B      m
     │ Int64  Int64  Float64
─────┼───────────────────────
   1 │     1      2  2.0
   2 │     2      1  1.66667
   3 │     3      2  1.22222

julia&gt; @eachrow df begin
           :A == 2 &amp;&amp; continue
           println(:A)
       end;
1
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/eachrow.jl#L79-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@groupby-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@groupby-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@groupby</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">groupby(df, args...)</code></pre><p>Group a data frame by columns. An alias for</p><pre><code class="nohighlight hljs">groupby(df, Cols(args...))</code></pre><p>but with a few convenience features.</p><p><strong>Details</strong></p><p><code>@groupby</code> does not perform any transformations or allow the generation of new columns. New column generation must be done before <code>@groupby</code> is called.</p><p><code>@groupby</code> allows mixing of <code>Symbol</code> and <code>String</code> inputs, such that <code>@groupby df :A &quot;B&quot;</code> is supported.</p><p>Arguments are not escaped and DataFramesMeta.jl rules for column selection, such as <code>$</code> for escaping, do not apply.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A = [1, 1], B = [3, 4], C = [6, 6]);
julia&gt; @groupby df :A;
julia&gt; @groupby df :A :B;
julia&gt; @groupby df [:A, :B];
julia&gt; @groupby df :A [:B, :C];</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L3016-L3048">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@kwarg-Tuple" href="#DataFramesMeta.@kwarg-Tuple"><code>DataFramesMeta.@kwarg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@kwarg(args...)</code></pre><p>Inside of DataFramesMeta.jl macros, pass keyword arguments to the underlying DataFrames.jl function when arguments are written in &quot;block&quot; format.</p><pre><code class="nohighlight hljs">julia&gt; df = DataFrame(x = [1, 1, 2, 2], b = [5, 6, 7, 8]);

julia&gt; @rsubset df begin
           :x == 1
           @kwarg view = true
       end
2×2 SubDataFrame
 Row │ x      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      5
   2 │     1      6</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This only has meaning inside DataFramesMeta.jl macros. It does not work outside of DataFrames.jl macros.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L502-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@label!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@label!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@label!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@label!(df, args...)</code></pre><p>Assign labels to columns in a data frame using <code>:col = label</code> syntax. Shorthand for <code>label!(df, ...)</code> from TablesMetaDataTools.jl.</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(wage = 12);

julia&gt; @label! df :wage = &quot;Wage per hour (USD)&quot;;

julia&gt; printlabels(df)
┌────────┬─────────────────────┐
│ Column │               Label │
├────────┼─────────────────────┤
│   wage │ Wage per hour (USD) │
└────────┴─────────────────────┘</code></pre><p>Use <code>@label!</code> for short descriptions, primarily for pretty printing. Use <code>@note!</code> for longer explanations of columns.</p><p>Labels are &quot;note&quot;-style columnar metadata. Labels are preserved upon renaming and transformations. <code>@label! :x = &quot;Lab&quot;</code> over-writes any existing label for the column <code>:x</code>. To add information without overwriting, use <a href="#DataFramesMeta.@note!-Tuple{Any, Vararg{Any}}"><code>@note!</code></a>.</p><p>Returns <code>df</code>, with the labels of <code>df</code> modified.</p><p>Like other DataFramesMeta.jl macros, <code>@label!</code> can be used in &quot;keyword&quot; format as well as block format.</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(wage = 12, tenure = 4);

julia&gt; @label! df begin
           :wage = &quot;Wage per hour (USD)&quot;
           :tenure = &quot;Tenure at job (months)&quot;
       end;

julia&gt; printlabels(df)
┌────────┬────────────────────────┐
│ Column │                  Label │
├────────┼────────────────────────┤
│   wage │    Wage per hour (USD) │
│ tenure │ Tenure at job (months) │
└────────┴────────────────────────┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/metadata.jl#L32-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@linq-Tuple{Any}" href="#DataFramesMeta.@linq-Tuple{Any}"><code>DataFramesMeta.@linq</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@linq df ...</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@linq</code> is deprecated. Use <code>@chain</code> instead. See <code>? @chain</code> for details.</p></div></div><p>General macro that creates a mini DSL for chaining and macro calls.</p><p><strong>Details</strong></p><p>The following embedded function calls are equivalent to their macro version:</p><ul><li><code>with</code></li><li><code>where</code></li><li><code>select</code></li><li><code>transform</code></li><li><code>by</code></li><li><code>groupby</code></li><li><code>orderby</code></li><li><code>combine</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFramesMeta, Statistics

julia&gt; df = DataFrame(
            a = repeat(1:4, outer = 2),
            b = repeat(2:-1:1, outer = 4),
            x = 1:8);

julia&gt; x1 = @linq transform(where(df, :a .&gt; 2, :b .!= &quot;c&quot;), :y = 10 .* :x);

julia&gt; x1 = @linq by(x1, :b, :meanX = mean(:x), :meanY = mean(:y));

julia&gt; @linq select(orderby(x1, :b, -:meanX), :var = :b, :meanX, :meanY)
2×3 DataFrame
│ Row │ var   │ meanX   │ meanY   │
│     │ Int64 │ Float64 │ Float64 │
├─────┼───────┼─────────┼─────────┤
│ 1   │ 1     │ 6.0     │ 60.0    │
│ 2   │ 2     │ 5.0     │ 50.0    │

julia&gt; @linq df |&gt;
           transform(y = 10 .* :x) |&gt;
           where(:a .&gt; 2) |&gt;
           by(:b, :meanX = mean(:x), :meanY = mean(:y)) |&gt;
           orderby(:meanX) |&gt;
           select(:meanX, :meanY, var = :b)
2×3 DataFrame
│ Row │ meanX   │ meanY   │ var   │
│     │ Float64 │ Float64 │ Int64 │
├─────┼─────────┼─────────┼───────┤
│ 1   │ 5.0     │ 50.0    │ 2     │
│ 2   │ 6.0     │ 60.0    │ 1     │
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/linqmacro.jl#L9-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@note!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@note!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@note!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@note!(df, args...)</code></pre><p>Assign notes to columns in a data frame using <code>:col = note</code> syntax. Shorthand for <code>note!(df, col, note)</code> from TablesMetadataTools.jl.</p><p>Use <code>@note!</code> for longer explanations of columns. Use <code>@label!</code> for short descriptions, primarily for pretty printing.</p><p>Returns <code>df</code>, with the notes of <code>df</code> modified.</p><pre><code class="language-julia-repl hljs">
julia&gt; df = DataFrame(wage = 12);

julia&gt; @note! df :wage = &quot;
       Wage per hour in 2014 USD taken from ACS data provided by IPUMS.

       Wage per hour is measured directly for hourly workers. For
       salaried workers, equal to salary / hours worked.
       &quot;;

julia&gt; printnotes(df)
Column: wage
────────────

Wage per hour in 2014 USD taken from ACS data provided by IPUMS.

Wage per hour is measured directly for hourly workers. For
salaried workers, equal to salary / hours worked.



julia&gt; @note! df :wage = &quot;Wage is capped at 99th percentile&quot;;

julia&gt; printnotes(df)
Column: wage
────────────

Wage per hour in 2014 USD taken from ACS data provided by IPUMS.

Wage per hour is measured directly for hourly workers. For
salaried workers, equal to salary / hours worked.

Wage is capped at 99th percentile</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/metadata.jl#L100-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@orderby-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@orderby-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@orderby</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@orderby(d, i...)</code></pre><p>Sort rows by values in one of several columns or a transformation of columns. Always returns a fresh <code>DataFrame</code>. Does not accept a <code>GroupedDataFrame</code>.</p><p><strong>Arguments</strong></p><ul><li><code>d</code>: a <code>DataFrame</code> or <code>GroupedDataFrame</code></li><li><code>i...</code>: arguments on which to sort the object</li></ul><p><strong>Details</strong></p><p>When given a <code>DataFrame</code>, <code>@orderby</code> applies the transformation given by its arguments (but does not create new columns) and sorts the given <code>DataFrame</code> on the result, returning a new <code>DataFrame</code>.</p><p>Inputs to <code>@orderby</code> can come in two formats: a <code>begin ... end</code> block, in which case each line in the block is a separate ordering operation, and as mulitple arguments. For example, the following two statements are equivalent:</p><pre><code class="language-julia hljs">@orderby df begin
    :x
    -:y
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@orderby(df, :x, -:y)</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>i...</code> : expression for sorting</li></ul><p>If an expression provided to <code>@orderby</code> begins with <code>@byrow</code>, operations are applied &quot;by row&quot; along the data frame. To avoid writing <code>@byrow</code> multiple times, <code>@orderby</code> also allows <code>@byrow</code>to be placed at the beginning of a block of operations. For example, the following two statements are equivalent.</p><pre><code class="nohighlight hljs">@orderby df @byrow begin
    :x^2
    :x^3
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@orderby df
    @byrow :x^2
    @byrow :x^3
end</code></pre><p>In operations, it is also allowed to use <code>AsTable(cols)</code> to work with multiple columns at once, where the columns are grouped together in a <code>NamedTuple</code>. When <code>AsTable(cols)</code> appears in a operation, no other columns may be referenced in the block.</p><p>Using <code>AsTable</code> in this way is useful for working with many columns at once programmatically. For example, to order rows by the sum of the columns <code>:a</code>, <code>:b</code>, and <code>:c</code>, write</p><pre><code class="nohighlight hljs">@byrow sum(AsTable([:a, :b, :c]))</code></pre><p>This constructs the pair</p><pre><code class="nohighlight hljs">AsTable([:a, :b, :c]) =&gt; ByRow(sum)</code></pre><p><code>AsTable</code> on the right-hand side also allows the use of the special column selectors <code>Not</code>, <code>Between</code>, and regular expressions. For example, to order all rows by the product of all columns starting with <code>&quot;a&quot;</code>, write</p><pre><code class="nohighlight hljs">@byrow prod(AsTable(r&quot;^a&quot;))</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta, Statistics

julia&gt; d = DataFrame(x = [3, 3, 3, 2, 1, 1, 1, 2, 1, 1], n = 1:10,
                     c = [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;e&quot;, &quot;d&quot;, &quot;g&quot;, &quot;f&quot;, &quot;i&quot;, &quot;j&quot;, &quot;h&quot;]);

julia&gt; @orderby(d, -:n)
10×3 DataFrame
 Row │ x      n      c
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     1     10  h
   2 │     1      9  j
   3 │     2      8  i
   4 │     1      7  f
   5 │     1      6  g
   6 │     1      5  d
   7 │     2      4  e
   8 │     3      3  b
   9 │     3      2  c
  10 │     3      1  a

julia&gt; @orderby(d, invperm(sortperm(:c, rev = true)))
10×3 DataFrame
 Row │ x      n      c
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     1      9  j
   2 │     2      8  i
   3 │     1     10  h
   4 │     1      6  g
   5 │     1      7  f
   6 │     2      4  e
   7 │     1      5  d
   8 │     3      2  c
   9 │     3      3  b
  10 │     3      1  a

julia&gt; @orderby d begin
           :x
           abs.(:n .- mean(:n))
       end
10×3 DataFrame
 Row │ x      n      c
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     1      5  e
   2 │     1      6  f
   3 │     1      7  g
   4 │     1      9  i
   5 │     1     10  j
   6 │     2      4  d
   7 │     2      8  h
   8 │     3      3  c
   9 │     3      2  b
  10 │     3      1  a

julia&gt; @orderby d @byrow :x^2
10×3 DataFrame
 Row │ x      n      c
     │ Int64  Int64  String
─────┼──────────────────────
   1 │     1      5  e
   2 │     1      6  f
   3 │     1      7  g
   4 │     1      9  i
   5 │     1     10  j
   6 │     2      4  d
   7 │     2      8  h
   8 │     3      1  a
   9 │     3      2  b
  10 │     3      3  c</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1250-L1388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@passmissing-Tuple" href="#DataFramesMeta.@passmissing-Tuple"><code>DataFramesMeta.@passmissing</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@passmissing(args...)</code></pre><p>Propagate missing values inside DataFramesMeta.jl macros.</p><p><code>@passmissing</code> is not a &quot;real&quot; Julia macro but rather serves as a &quot;flag&quot; to indicate that the anonymous function created by DataFramesMeta.jl to represent an operation should be wrapped in <code>passmissing</code> from Missings.jl.</p><p><code>@passmissing</code> can only be combined with <code>@byrow</code> or the row-wise versions of macros such as <code>@rtransform</code> and <code>@rselect</code>, etc. If any of the arguments passed to the row-wise anonymous function created by DataFramesMeta.jl with <code>@byrow</code>, the result will automatically be <code>missing</code>.</p><p>In the below example, <code>@transform</code> would throw an error without the <code>@passmissing</code> flag.</p><p><code>@passmissing</code> is especially useful for functions which operate on strings, such as <code>parse</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; no_missing(x::Int, y::Int) = x + y;

julia&gt; df = DataFrame(a = [1, 2, missing], b = [4, 5, 6])
3×2 DataFrame
 Row │ a        b
     │ Int64?   Int64
─────┼────────────────
   1 │       1      4
   2 │       2      5
   3 │ missing      6

julia&gt; @transform df @passmissing @byrow c = no_missing(:a, :b)
3×3 DataFrame
 Row │ a        b      c
     │ Int64?   Int64  Int64?
─────┼─────────────────────────
   1 │       1      4        5
   2 │       2      5        7
   3 │ missing      6  missing

julia&gt; df = DataFrame(x_str = [&quot;1&quot;, &quot;2&quot;, missing])
3×1 DataFrame
 Row │ x_str
     │ String?
─────┼─────────
   1 │ 1
   2 │ 2
   3 │ missing

julia&gt; @rtransform df @passmissing x = parse(Int, :x_str)
3×2 DataFrame
 Row │ x_str    x
     │ String?  Int64?
─────┼──────────────────
   1 │ 1              1
   2 │ 2              2
   3 │ missing  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L285-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rdistinct!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rdistinct!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rdistinct!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">rdistinct!(d, args...)</code></pre><p>Row-wise version of <code>@distinct!</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@distinct!-Tuple{Any, Vararg{Any}}"><code>@distinct!</code></a> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(x = 1:5, y = 5:-1:1)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     5
   2 │     2     4
   3 │     3     3
   4 │     4     2
   5 │     5     1
   
julia&gt; @rdistinct!(df, :x + :y)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2739-L2767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rdistinct-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rdistinct-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rdistinct</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">rdistinct(d, args...)</code></pre><p>Row-wise version of <code>@distinct</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@distinct-Tuple{Any, Vararg{Any}}"><code>@distinct</code></a> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(x = 1:5, y = 5:-1:1)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     5
   2 │     2     4
   3 │     3     3
   4 │     4     2
   5 │     5     1
   
julia&gt; @rdistinct(df, :x + :y)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2567-L2595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rename!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rename!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rename!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rename!(d, args...)</code></pre><p>In-place modification of column names.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>args...</code> : expressions of the form <code>:new = :old</code> specifying the change of a column&#39;s name</li></ul><p>from &quot;old&quot; to &quot;new&quot;. The left- and right-hand side of each expression can be passed as symbol arguments, as in <code>:old_col</code>, or strings escaped with <code>$</code> as in <code>$&quot;new_col&quot;</code>. See  <strong>Details</strong> for a description of accepted values.</p><p><strong>Returns</strong></p><ul><li><code>::AbstractDataFrame</code></li></ul><p>Inputs to <code>@rename!</code> can come in two formats: a <code>begin ... end</code> block, or as a series of keyword-like arguments. For example, the following are equivalent:</p><pre><code class="language-julia hljs">@rename! df begin
    :new_col = :old_col
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@rename!(df, :new_col = :old_col)</code></pre><p><strong>Details</strong></p><p>Both the left- and right-hand side of an expression specifying a column name assignment can be either a <code>Symbol</code> or a <code>String</code><code>escaped with</code><span>$` For example `:new = ...`, and `$</span>&quot;new&quot; = ...` are both valid ways of assigning a new column name.</p><p>This idea can be extended to pass arbitrary right-hand side expressions. For example, the following are equivalent:</p><pre><code class="nohighlight hljs">@rename!(df, :new = :old1)</code></pre><p>and</p><pre><code class="nohighlight hljs">@rename!(df, :new = old_col1)</code></pre><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; df = DataFrame(old_col1 = rand(5), old_col2 = rand(5),old_col3 = rand(5));

julia&gt; @rename!(df, :new1 = :old_col1)
5×3 DataFrame
 Row │ new1       old_col2   old_col3
     │ Float64    Float64    Float64
─────┼────────────────────────────────
   1 │ 0.0176206  0.493592   0.348072
   2 │ 0.861545   0.512254   0.85763
   3 │ 0.263082   0.0267507  0.696494
   4 │ 0.643179   0.299391   0.780125
   5 │ 0.731267   0.18905    0.767292

julia&gt; df = DataFrame(old_col1 = rand(5), old_col2 = rand(5),old_col3 = rand(5));

julia&gt; @rename!(df, :new1 = :old_col1, :new2 = $&quot;old_col2&quot;)
5×3 DataFrame
 Row │ new1       new2       old_col3
     │ Float64    Float64    Float64
─────┼────────────────────────────────
   1 │ 0.0176206  0.493592   0.348072
   2 │ 0.861545   0.512254   0.85763
   3 │ 0.263082   0.0267507  0.696494
   4 │ 0.643179   0.299391   0.780125
   5 │ 0.731267   0.18905    0.767292

julia&gt; df = DataFrame(old_col1 = rand(5), old_col2 = rand(5),old_col3 = rand(5));

julia&gt; @rename!(df, :new1 = $(&quot;old_col&quot; * &quot;1&quot;), :new2 = :old_col2)
5×3 DataFrame
 Row │ new1       new2       old_col3
     │ Float64    Float64    Float64
─────┼────────────────────────────────
   1 │ 0.0176206  0.493592   0.348072
   2 │ 0.861545   0.512254   0.85763
   3 │ 0.263082   0.0267507  0.696494
   4 │ 0.643179   0.299391   0.780125
   5 │ 0.731267   0.18905    0.767292</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2914-L3006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rename-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rename-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rename</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rename(d, args...)</code></pre><p>Change column names.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>args...</code> : expressions of the form <code>:new = :old</code> specifying the change of a column&#39;s name</li></ul><p>from &quot;old&quot; to &quot;new&quot;. The left- and right-hand side of each expression can be passed as symbol arguments, as in <code>:old_col</code>, or strings escaped with <code>$</code> as in <code>$&quot;new_col&quot;</code>. See  <strong>Details</strong> for a description of accepted values.</p><p><strong>Returns</strong></p><ul><li><code>::AbstractDataFrame</code></li></ul><p>Inputs to <code>@rename</code> can come in two formats: a <code>begin ... end</code> block, or as a series of keyword-like arguments. For example, the following are equivalent:</p><pre><code class="language-julia hljs">@rename df begin
    :new_col = :old_col
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@rename df :new_col = :old_col
@rename(df, :new_col = :old_col)</code></pre><p><strong>Details</strong></p><p>Both the left- and right-hand side of an expression specifying a column name assignment can be either a <code>Symbol</code> or an <code>AbstractString</code> (which may contain spaces) escaped with <code>$</code>. For example <code>:new = ...</code>, and <code>$&quot;new&quot; = ...</code> are both valid ways of assigning a new column name.</p><p>This idea can be extended to pass arbitrary right-hand side expressions. For example, the following are equivalent:</p><pre><code class="nohighlight hljs">@rename(df, :new = :old1)</code></pre><p>and</p><pre><code class="nohighlight hljs">@rename(df, :new = old_col1)</code></pre><p>The right-hand side can additionally be an <code>Integer</code>, escaped with $, to indicate column position. For example, to rename the 4th column in a data frame to a new name, write <code>@rename df :newname = $</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; df = DataFrame(old_col1 = 1:5, old_col2 = 11:15, old_col3 = 21:25);

julia&gt; @rename(df, :new1 = :old_col1)
5×3 DataFrame
 Row │ new1   old_col2  old_col3
     │ Int64  Int64     Int64
─────┼───────────────────────────
   1 │     1        11        21
   2 │     2        12        22
   3 │     3        13        23
   4 │     4        14        24
   5 │     5        15        25

julia&gt; @rename(df, :new1 = :old_col1, :new2 = $&quot;old_col2&quot;)
5×3 DataFrame
 Row │ new1   new2   old_col3
     │ Int64  Int64  Int64
─────┼────────────────────────
   1 │     1     11        21
   2 │     2     12        22
   3 │     3     13        23
   4 │     4     14        24
   5 │     5     15        25

julia&gt; @rename(df, :new1 = $(&quot;old_col&quot; * &quot;1&quot;), :new2 = :old_col2)
5×3 DataFrame
 Row │ new1   new2   old_col3
     │ Int64  Int64  Int64
─────┼────────────────────────
   1 │     1     11        21
   2 │     2     12        22
   3 │     3     13        23
   4 │     4     14        24
   5 │     5     15        25

julia&gt; @rename df $(&quot;New with spaces&quot;) = :old_col1
5×3 DataFrame
 Row │ New with spaces  old_col2  old_col3
     │ Int64            Int64     Int64
─────┼─────────────────────────────────────
   1 │               1        11        21
   2 │               2        12        22
   3 │               3        13        23
   4 │               4        14        24
   5 │               5        15        25

julia&gt; @rename df :new_col2 = $2
5×3 DataFrame
 Row │ old_col1  new_col2  old_col3
     │ Int64     Int64     Int64
─────┼──────────────────────────────
   1 │        1        11        21
   2 │        2        12        22
   3 │        3        13        23
   4 │        4        14        24
   5 │        5        15        25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2785-L2901">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rorderby-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rorderby-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rorderby</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rorderby(d, args...)</code></pre><p>Row-wise version of <code>@orderby</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@orderby-Tuple{Any, Vararg{Any}}"><code>@orderby</code></a> for details.</p><p>Use this function as an alternative to placing the <code>.</code> to broadcast row-wise operations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(x = [8,8,-8,7,7,-7], y = [-1, 1, -2, 2, -3, 3])
6×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     8     -1
   2 │     8      1
   3 │    -8     -2
   4 │     7      2
   5 │     7     -3
   6 │    -7      3

julia&gt; @rorderby df abs(:x) (:x * :y^3)
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     7     -3
   2 │    -7      3
   3 │     7      2
   4 │     8     -1
   5 │     8      1
   6 │    -8     -2

julia&gt;  @rorderby df :y == 2 ? -:x : :y
6×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     7      2
   2 │     7     -3
   3 │    -8     -2
   4 │     8     -1
   5 │     8      1
   6 │    -7      3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1401-L1448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rselect!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rselect!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rselect!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rselect!(x, args...; kwargs...)</code></pre><p>Row-wise version of <code>@select!</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@select!-Tuple{Any, Vararg{Any}}"><code>@select!</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L2129-L2134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rselect-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rselect-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rselect</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rselect(x, args...; kwargs...)</code></pre><p>Row-wise version of <code>@select</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@select-Tuple{Any, Vararg{Any}}"><code>@select</code></a> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(x = 1:5, y = 10:14)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     10
   2 │     2     11
   3 │     3     12
   4 │     4     13
   5 │     5     14

julia&gt; @rselect(df, :x, :A = mod(:y, :x) == 0 ? 99 : :x)
5×2 DataFrame
 Row │ x      A
     │ Int64  Int64
─────┼──────────────
   1 │     1     99
   2 │     2      2
   3 │     3     99
   4 │     4      4
   5 │     5      5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1940-L1972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rsubset!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rsubset!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rsubset!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rsubset!(d, i...)</code></pre><p>Row-wise version of <code>@subset!</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@subset!-Tuple{Any, Vararg{Any}}"><code>@subset!</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1212-L1217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rsubset-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rsubset-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rsubset</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rsubset(d, i...; kwargs...)</code></pre><p>Row-wise version of <code>@subset</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@subset-Tuple{Any, Vararg{Any}}"><code>@subset</code></a> for details.</p><p>Use this function as an alternative to placing the <code>.</code> to broadcast row-wise operations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(A=1:5, B=[&quot;apple&quot;, &quot;pear&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;])
5×2 DataFrame
 Row │ A      B
     │ Int64  String
─────┼───────────────
   1 │     1  apple
   2 │     2  pear
   3 │     3  apple
   4 │     4  orange
   5 │     5  pear

julia&gt; @rsubset df :A &gt; 3
2×2 DataFrame
 Row │ A      B
     │ Int64  String
─────┼───────────────
   1 │     4  orange
   2 │     5  pear

julia&gt; @rsubset df :A &gt; 3 || :B == &quot;pear&quot;
3×2 DataFrame
  Row │ A      B
      │ Int64  String
 ─────┼───────────────
    1 │     2  pear
    2 │     4  orange
    3 │     5  pear</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L970-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rtransform!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rtransform!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rtransform!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rtransform!(x, args...; kwargs...)</code></pre><p>Row-wise version of <code>@transform!</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@transform!-Tuple{Any, Vararg{Any}}"><code>@transform!</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1771-L1775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@rtransform-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@rtransform-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@rtransform</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rtransform(x, args...; kwargs...)</code></pre><p>Row-wise version of <code>@transform</code>, i.e. all operations use <code>@byrow</code> by default. See <a href="#DataFramesMeta.@transform-Tuple{Any, Vararg{Any}}"><code>@transform</code></a> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(x = 1:5, y = 11:15)
5×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     1     11
   2 │     2     12
   3 │     3     13
   4 │     4     14
   5 │     5     15

julia&gt; @rtransform(df, :a = :x + :y ^ 2, :c = :y == 13 ? 999 : 1 - :y)
5×4 DataFrame
 Row │ x      y      a      c
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1     11    122    -10
   2 │     2     12    146    -11
   3 │     3     13    172    999
   4 │     4     14    200    -13
   5 │     5     15    230    -14</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1604-L1636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@select!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@select!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@select!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@select!(d, i...; kwargs...)</code></pre><p>Mutate <code>d</code> in-place to retain only columns or transformations specified by <code>e</code> and return it. No copies of existing columns are made.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame</li><li><code>i</code> : transformations of the form <code>:y = f(:x)</code> specifying</li></ul><p>new columns in terms of existing columns or symbols to specify existing columns</p><ul><li><code>kwargs</code> : keyword arguments passed to <code>DataFrames.select!</code></li></ul><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code></li></ul><p><strong>Details</strong></p><p>Inputs to <code>@select!</code> can come in two formats: a <code>begin ... end</code> block, in which case each line in the block is a separate transformation or selector, or as a series of arguments and keyword-like arguments. For example, the following are equivalent:</p><p><code>@select!</code> uses the syntax <code>@byrow</code> to wrap transformations in the <code>ByRow</code> function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call</p><pre><code class="nohighlight hljs">@select!(df, @byrow :y = :x == 1 ? true : false)</code></pre><p>becomes</p><pre><code class="nohighlight hljs">select!(df, :x =&gt; ByRow(x -&gt; x == 1 ? true : false) =&gt; :y)</code></pre><p>a transformation which cannot be conveniently expressed using broadcasting.</p><p>To avoid writing <code>@byrow</code> multiple times when performing multiple transformations by row, <code>@select!</code> allows <code>@byrow</code> at the beginning of a block of select!ations (i.e. <code>@byrow begin... end</code>). All transformations in the block will operate by row.</p><p>To select many columns at once use the tools <code>Not</code>, <code>Between</code>, <code>All</code>, and <code>Cols</code>.</p><ul><li><code>@select df Not(:a)</code> keeps all columns except for <code>:a</code></li><li><code>@select df Between(:a, :z)</code> keeps all columns between <code>:a</code> and <code>:z</code>, inclusive</li><li><code>@select df All()</code> keeps all columns</li><li><code>@select df Cols(...)</code> can be used to combine many different selectors, as well as use regular expressions. For example <code>Cols(r&quot;a&quot;)</code> selects all columns that start with <code>&quot;a&quot;</code>.</li></ul><p>Transformations can also use the macro-flag <a href="#DataFramesMeta.@astable-Tuple"><code>@astable</code></a> for creating multiple new columns at once and letting transformations share the same name-space. See <code>? @astable</code> for more details.</p><p>In operations, it is also allowed to use <code>AsTable(cols)</code> to work with multiple columns at once, where the columns are grouped together in a <code>NamedTuple</code>. When <code>AsTable(cols)</code> appears in a operation, no other columns may be referenced in the block.</p><p>Using <code>AsTable</code> in this way is useful for working with many columns at once programmatically. For example, to compute the row-wise sum of the columns <code>[:a, :b, :c, :d]</code>, write</p><pre><code class="nohighlight hljs">@byrow :c = sum(AsTable([:a, :b, :c, :d]))</code></pre><p>This constructs the pairs</p><pre><code class="nohighlight hljs">AsTable(nms) =&gt; ByRow(sum) =&gt; :c</code></pre><p><code>AsTable</code> on the right-hand side also allows the use of the special column selectors <code>Not</code>, <code>Between</code>, and regular expressions. For example, to calculate the product of all the columns beginning with the letter <code>&quot;a&quot;</code>, write</p><pre><code class="nohighlight hljs">@byrow :d = prod(AsTable(r&quot;^a&quot;))</code></pre><p><code>@select!</code> accepts the same keyword arguments as <code>DataFrames.select!</code> and can be added in two ways. When inputs are given as multiple arguments, they are added at the end after a semi-colon <code>;</code>, as in</p><pre><code class="nohighlight hljs">@select!(gd, :a; ungroup = false)</code></pre><p>When inputs are given in &quot;block&quot; format, the last lines may be written <code>@kwarg key = value</code>, which indicates keyword arguments to be passed to <code>select!</code> function.</p><pre><code class="nohighlight hljs">@select! gd begin
    :a
    @kwarg ungroup = false
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames, DataFramesMeta

julia&gt; df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);

julia&gt; df2 = @select!(df, :c, :a)
8×2 DataFrame
 Row │ c      a
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      1
   6 │     6      2
   7 │     7      3
   8 │     8      4

julia&gt; df === df2
true

julia&gt; df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);

julia&gt; df2 = @select! df begin
           :c
           :x = :b + :c
       end
8×2 DataFrame
 Row │ c      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      3
   3 │     3      5
   4 │     4      5
   5 │     5      7
   6 │     6      7
   7 │     7      9
   8 │     8      9

julia&gt; df === df2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1993-L2115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@select-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@select-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@select</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@select(d, i...; kwargs...)</code></pre><p>Select and transform columns.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an <code>AbstractDataFrame</code> or <code>GroupedDataFrame</code></li><li><code>i</code> :  transformations of the form <code>:y = f(:x)</code> specifying</li></ul><p>new columns in terms of existing columns or symbols to specify existing columns</p><ul><li><code>kwargs</code> : keyword arguments passed to <code>DataFrames.select</code></li></ul><p><strong>Returns</strong></p><ul><li><code>::AbstractDataFrame</code> or a <code>GroupedDataFrame</code></li></ul><p><strong>Details</strong></p><p>Inputs to <code>@select</code> can come in two formats: a <code>begin ... end</code> block, in which case each line in the block is a separate transformation or selector, or as a series of arguments and keyword-like arguments arguments. For example, the following are equivalent:</p><pre><code class="language-julia hljs">@select df begin
    :x
    :y = :a .+ :b
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@select(df, :x, :y = :a .+ :b)</code></pre><p><code>@select</code> uses the syntax <code>@byrow</code> to wrap transformations in the <code>ByRow</code> function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call</p><pre><code class="nohighlight hljs">@select(df, @byrow :y = :x == 1 ? true : false)</code></pre><p>becomes</p><pre><code class="nohighlight hljs">select(df, :x =&gt; ByRow(x -&gt; x == 1 ? true : false) =&gt; :y)</code></pre><p>a transformation which cannot be conveniently expressed using broadcasting.</p><p>To avoid writing <code>@byrow</code> multiple times when performing multiple transformations by row, <code>@select</code> allows <code>@byrow</code> at the beginning of a block of selections (i.e. <code>@byrow begin... end</code>). All transformations in the block will operate by row.</p><p>To select many columns at once use the tools <code>Not</code>, <code>Between</code>, <code>All</code>, and <code>Cols</code>.</p><ul><li><code>@select df Not(:a)</code> keeps all columns except for <code>:a</code></li><li><code>@select df Between(:a, :z)</code> keeps all columns between <code>:a</code> and <code>:z</code>, inclusive</li><li><code>@select df All()</code> keeps all columns</li><li><code>@select df Cols(...)</code> can be used to combine many different selectors, as well as use regular expressions. For example <code>Cols(r&quot;a&quot;)</code> selects all columns that start with <code>&quot;a&quot;</code>.</li></ul><p>Expressions inside <code>Not(...)</code>, <code>Between(...)</code> etc. are untouched by DataFramesMeta&#39;s parsing. To refer to a variable <code>x</code> which represents a column inside <code>Not</code>, write <code>Not(x)</code>, rather than <code>Not($x)</code>.</p><p>Transformations can also use the macro-flag <a href="#DataFramesMeta.@astable-Tuple"><code>@astable</code></a> for creating multiple new columns at once and letting transformations share the same name-space. See <code>? @astable</code> for more details.</p><p>In operations, it is also allowed to use <code>AsTable(cols)</code> to work with multiple columns at once, where the columns are grouped together in a <code>NamedTuple</code>. When <code>AsTable(cols)</code> appears in a operation, no other columns may be referenced in the block.</p><p>Using <code>AsTable</code> in this way is useful for working with many columns at once programmatically. For example, to compute the row-wise sum of the columns <code>[:a, :b, :c, :d]</code>, write</p><pre><code class="nohighlight hljs">@byrow :c = sum(AsTable([:a, :b, :c, :d]))</code></pre><p>This constructs the pairs</p><pre><code class="nohighlight hljs">AsTable(nms) =&gt; ByRow(sum) =&gt; :c</code></pre><p><code>AsTable</code> on the right-hand side also allows the use of the special column selectors <code>Not</code>, <code>Between</code>, and regular expressions. For example, to calculate the product of all the columns beginning with the letter <code>&quot;a&quot;</code>, write</p><pre><code class="nohighlight hljs">@byrow :d = prod(AsTable(r&quot;^a&quot;))</code></pre><p><code>@select</code> accepts the same keyword arguments as <code>DataFrames.select</code> and can be added in two ways. When inputs are given as multiple arguments, they are added at the end after a semi-colon <code>;</code>, as in</p><pre><code class="nohighlight hljs">@select(df, :a; copycols = false)</code></pre><p>When inputs are given in &quot;block&quot; format, the last lines may be written <code>@kwarg key = value</code>, which indicates keyword arguments to be passed to <code>select</code> function.</p><pre><code class="nohighlight hljs">@select gd begin
    :a
    @kwarg copycols = false
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);

julia&gt; @select(df, :c, :a)
8×2 DataFrame
 Row │ c      a
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      2
   3 │     3      3
   4 │     4      4
   5 │     5      1
   6 │     6      2
   7 │     7      3
   8 │     8      4

julia&gt; @select df begin
           :c
           :x = :b + :c
       end
8×2 DataFrame
 Row │ c      x
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      3
   3 │     3      5
   4 │     4      5
   5 │     5      7
   6 │     6      7
   7 │     7      9
   8 │     8      9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1795-L1926">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@subset!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@subset!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@subset!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@subset!(d, i...; kwargs...)</code></pre><p>Select row subsets in <code>AbstractDataFrame</code>s and <code>GroupedDataFrame</code>s, mutating the underlying data-frame in-place.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame or GroupedDataFrame</li><li><code>i...</code> : expression for selecting rows</li><li><code>kwargs</code> : keyword arguments passed to <code>DataFrames.subset!</code></li></ul><p><strong>Details</strong></p><p>Multiple <code>i</code> expressions are &quot;and-ed&quot; together.</p><p>If given a <code>GroupedDataFrame</code>, <code>@subset!</code> applies transformations by group, and returns a fresh <code>DataFrame</code> containing the rows for which the generated values are all <code>true</code>.</p><p>Inputs to <code>@subset!</code> can come in two formats: a <code>begin ... end</code> block, in which case each line is a separate selector, or as multiple arguments. For example the following two statements are equivalent:</p><pre><code class="language-julia hljs">@subset! df begin
    :x .&gt; 1
    :y .&lt; 2
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@subset!(df, :x .&gt; 1, :y .&lt; 2)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@subset!</code> treats <code>missing</code> values as <code>false</code> when filtering rows. Unlike <code>DataFrames.subset!</code> and other Boolean operations with <code>missing</code>, <code>@subset!</code> will <em>not</em> error on missing values, and will only keep <code>true</code> values.</p></div></div><p>If an expression provided to <code>@subset!</code> begins with <code>@byrow</code>, operations are applied &quot;by row&quot; along the data frame. To avoid writing <code>@byrow</code> multiple times, <code>@orderby</code> also allows <code>@byrow</code>to be placed at the beginning of a block of operations. For example, the following two statements are equivalent.</p><pre><code class="nohighlight hljs">@subset! df @byrow begin
    :x &gt; 1
    :y &lt; 2
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@subset! df
    @byrow :x &gt; 1
    @byrow :y &lt; 2
end</code></pre><p>In operations, it is also allowed to use <code>AsTable(cols)</code> to work with multiple columns at once, where the columns are grouped together in a <code>NamedTuple</code>. When <code>AsTable(cols)</code> appears in a operation, no other columns may be referenced in the block.</p><p>Using <code>AsTable</code> in this way is useful for working with many columns at once programmatically. For example, to select rows where the sum of the columns <code>:a</code>, <code>:b</code>, and <code>:c</code> is greater than <code>5</code>, write</p><pre><code class="nohighlight hljs">@byrow sum(AsTable([:a, :b, :c])) &gt; 5</code></pre><p>This constructs the pair</p><pre><code class="nohighlight hljs">AsTable([:a, :b, :c]) =&gt; ByRow(t -&gt; sum(t) &gt; 5)</code></pre><p><code>AsTable</code> on the right-hand side also allows the use of the special column selectors <code>Not</code>, <code>Between</code>, and regular expressions. For example, to subset all rows where the product of all columns starting with <code>&quot;a&quot;</code>, is greater than <code>5</code>, write</p><pre><code class="nohighlight hljs">@byrow prod(AsTable(r&quot;^a&quot;)) &gt; 5</code></pre><p><code>@subset!</code> accepts the same keyword arguments as <code>DataFrames.subset!</code> and can be added in two ways. When inputs are given as multiple arguments, they are added at the end after a semi-colon <code>;</code>, as in</p><pre><code class="nohighlight hljs">@subset!(df, :a; skipmissing = false)</code></pre><p>When inputs are given in &quot;block&quot; format, the last lines may be written <code>@kwarg key = value</code>, which indicates keyword arguments to be passed to <code>subset!</code> function.</p><pre><code class="nohighlight hljs">@subset! df begin
    :a .== 1
    @kwarg skipmissing = false
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta, Statistics

julia&gt; df = DataFrame(x = 1:3, y = [2, 1, 2]);

julia&gt; globalvar = [2, 1, 0];

julia&gt; @subset!(copy(df), :x .&gt; 1)
2×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     2      1
   2 │     3      2

julia&gt; @subset!(copy(df), :x .&gt; globalvar)
2×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     2      1
   2 │     3      2

julia&gt; @subset! copy(df) begin
           :x .&gt; globalvar
           :y .== 3
       end
0×2 DataFrame

julia&gt; df = DataFrame(n = 1:20, x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1,
                                    2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);

julia&gt; g = groupby(copy(df), :x);

julia&gt; @subset!(g, :n .&gt; mean(:n))
8×2 DataFrame
 Row │ n      x
     │ Int64  Int64
─────┼──────────────
   1 │    12      1
   2 │    13      1
   3 │    15      2
   4 │    16      2
   5 │    17      3
   6 │    18      1
   7 │    19      1
   8 │    20      2

julia&gt; g = groupby(copy(df), :x);

julia&gt; @subset! g begin
           :n .&gt; mean(:n)
           :n .&lt; 20
       end
7×2 DataFrame
 Row │ n      x
     │ Int64  Int64
─────┼──────────────
   1 │    12      1
   2 │    13      1
   3 │    15      2
   4 │    16      2
   5 │    17      3
   6 │    18      1
   7 │    19      1

julia&gt; d = DataFrame(a = [1, 2, missing], b = [&quot;x&quot;, &quot;y&quot;, missing]);

julia&gt; @subset!(d, :a .== 1)
1×2 DataFrame
 Row │ a       b
     │ Int64?  String?
─────┼─────────────────
   1 │      1  x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1045-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@subset-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@subset-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@subset</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@subset(d, i...; kwargs...)</code></pre><p>Select row subsets in <code>AbstractDataFrame</code>s and <code>GroupedDataFrame</code>s.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame or GroupedDataFrame</li><li><code>i...</code> : expression for selecting rows</li><li><code>kwargs...</code> : keyword arguments passed to <code>DataFrames.subset</code></li></ul><p><strong>Details</strong></p><p>Multiple <code>i</code> expressions are &quot;and-ed&quot; together.</p><p>If given a <code>GroupedDataFrame</code>, <code>@subset</code> applies transformations by group, and returns a fresh <code>DataFrame</code> containing the rows for which the generated values are all <code>true</code>.</p><p>Inputs to <code>@subset</code> can come in two formats: a <code>begin ... end</code> block, in which case each line is a separate selector, or as multiple arguments. For example the following two statements are equivalent:</p><pre><code class="language-julia hljs">@subset df begin
    :x .&gt; 1
    :y .&lt; 2
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@subset(df, :x .&gt; 1, :y .&lt; 2)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@subset</code> treats <code>missing</code> values as <code>false</code> when filtering rows. Unlike <code>DataFrames.subset</code> and other Boolean operations with <code>missing</code>, <code>@subset</code> will <em>not</em> error on missing values, and will only keep <code>true</code> values.</p></div></div><p>If an expression provided to <code>@subset</code> begins with <code>@byrow</code>, operations are applied &quot;by row&quot; along the data frame. To avoid writing <code>@byrow</code> multiple times, <code>@orderby</code> also allows <code>@byrow</code> to be placed at the beginning of a block of operations. For example, the following two statements are equivalent.</p><pre><code class="nohighlight hljs">@subset df @byrow begin
    :x &gt; 1
    :y &lt; 2
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@subset df
    @byrow :x &gt; 1
    @byrow :y &lt; 2
end</code></pre><p>In operations, it is also allowed to use <code>AsTable(cols)</code> to work with multiple columns at once, where the columns are grouped together in a <code>NamedTuple</code>. When <code>AsTable(cols)</code> appears in a operation, no other columns may be referenced in the block.</p><p>Using <code>AsTable</code> in this way is useful for working with many columns at once programmatically. For example, to select rows where the sum of the columns <code>:a</code>, <code>:b</code>, and <code>:c</code> is greater than <code>5</code>, write</p><pre><code class="nohighlight hljs">@byrow sum(AsTable([:a, :b, :c])) &gt; 5</code></pre><p>This constructs the pair</p><pre><code class="nohighlight hljs">AsTable([:a, :b, :c]) =&gt; ByRow(t -&gt; sum(t) &gt; 5)</code></pre><p><code>AsTable</code> on the right-hand side also allows the use of the special column selectors <code>Not</code>, <code>Between</code>, and regular expressions. For example, to subset all rows where the product of all columns starting with <code>&quot;a&quot;</code>, is greater than <code>5</code>, write</p><pre><code class="nohighlight hljs">@byrow prod(AsTable(r&quot;^a&quot;)) &gt; 5</code></pre><p><code>@subset</code> accepts the same keyword arguments as <code>DataFrames.subset</code> and can be added in two ways. When inputs are given as multiple arguments, they are added at the end after a semi-colon <code>;</code>, as in</p><pre><code class="nohighlight hljs">@subset(df, :a; skipmissing = false, view = true)</code></pre><p>When inputs are given in &quot;block&quot; format, the last lines may be written <code>@kwarg key = value</code>, which indicates keyword arguments to be passed to <code>subset</code> function.</p><pre><code class="nohighlight hljs">@subset df begin
    :a .== 1
    @kwarg skipmissing = false
    @kwarg view = true
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta, Statistics

julia&gt; df = DataFrame(x = 1:3, y = [2, 1, 2]);

julia&gt; globalvar = [2, 1, 0];

julia&gt; @subset(df, :x .&gt; 1)
2×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     2      1
   2 │     3      2

julia&gt; @subset(df, :x .&gt; globalvar)
2×2 DataFrame
 Row │ x      y
     │ Int64  Int64
─────┼──────────────
   1 │     2      1
   2 │     3      2

julia&gt; @subset df begin
           :x .&gt; globalvar
           :y .== 3
       end
0×2 DataFrame

julia&gt; df = DataFrame(n = 1:20, x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1,
                                    2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);

julia&gt; g = groupby(df, :x);

julia&gt; @subset(g, :n .&gt; mean(:n))
8×2 DataFrame
 Row │ n      x
     │ Int64  Int64
─────┼──────────────
   1 │    12      1
   2 │    13      1
   3 │    15      2
   4 │    16      2
   5 │    17      3
   6 │    18      1
   7 │    19      1
   8 │    20      2

julia&gt; @subset g begin
           :n .&gt; mean(:n)
           :n .&lt; 20
       end
7×2 DataFrame
 Row │ n      x
     │ Int64  Int64
─────┼──────────────
   1 │    12      1
   2 │    13      1
   3 │    15      2
   4 │    16      2
   5 │    17      3
   6 │    18      1
   7 │    19      1

julia&gt; df = DataFrame(a = [1, 2, missing], b = [&quot;x&quot;, &quot;y&quot;, missing]);

julia&gt; @subset(df, :a .== 1)
1×2 DataFrame
 Row │ a       b
     │ Int64?  String?
─────┼─────────────────
   1 │      1  x

julia&gt; @subset(df, :a .&lt; 3; view = true)
2×2 SubDataFrame
 Row │ a       b
     │ Int64?  String?
─────┼─────────────────
   1 │      1  x
   2 │      2  y

julia&gt; @subset df begin
           :a .&lt; 3
           @kwarg view = true
       end
2×2 SubDataFrame
 Row │ a       b
     │ Int64?  String?
─────┼─────────────────
   1 │      1  x
   2 │      2  y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L777-L955">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@transform!-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@transform!-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@transform!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@transform!(d, i...; kwargs...)</code></pre><p>Mutate <code>d</code> inplace to add additional columns or keys based on keyword-like arguments and return it. No copies of existing columns are made.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an <code>AbstractDataFrame</code>, or <code>GroupedDataFrame</code></li><li><code>i...</code> : transformations of the form <code>:y = f(:x)</code> defining new columns or keys</li><li><code>kwargs...</code>: keyword arguments passed to <code>DataFrames.transform!</code></li></ul><p><strong>Returns</strong></p><ul><li><code>::DataFrame</code> or a <code>GroupedDataFrame</code></li></ul><p><strong>Details</strong></p><p>Inputs to <code>@transform!</code> can come in two formats: a <code>begin ... end</code> block, in which case each line in the block is a separate transformation, (<code>:y = f(:x)</code>), or as a series of keyword-like arguments. For example, the following are equivalent:</p><pre><code class="language-julia hljs">@transform! df begin
    :a = :x
    :b = :y
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@transform!(df, :a = :x, :b = :y)</code></pre><p><code>@transform!</code> uses the syntax <code>@byrow</code> to wrap transform!ations in the <code>ByRow</code> function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call</p><pre><code class="nohighlight hljs">@transform!(df, @byrow :y = :x == 1 ? true : false)</code></pre><p>becomes</p><pre><code class="nohighlight hljs">transform!(df, :x =&gt; ByRow(x -&gt; x == 1 ? true : false) =&gt; :y)</code></pre><p>a transformation which cannot be conveniently expressed using broadcasting.</p><p>To avoid writing <code>@byrow</code> multiple times when performing multiple transform!ations by row, <code>@transform!</code> allows <code>@byrow</code> at the beginning of a block of transform!ations (i.e. <code>@byrow begin... end</code>). All transform!ations in the block will operate by row.</p><p>Transformations can also use the macro-flag <a href="#DataFramesMeta.@astable-Tuple"><code>@astable</code></a> for creating multiple new columns at once and letting transformations share the same name-space. See <code>? @astable</code> for more details.</p><p>In operations, it is also allowed to use <code>AsTable(cols)</code> to work with multiple columns at once, where the columns are grouped together in a <code>NamedTuple</code>. When <code>AsTable(cols)</code> appears in a operation, no other columns may be referenced in the block.</p><p>Using <code>AsTable</code> in this way is useful for working with many columns at once programmatically. For example, to compute the row-wise sum of the columns <code>[:a, :b, :c, :d]</code>, write</p><pre><code class="nohighlight hljs">@byrow :c = sum(AsTable([:a, :b, :c, :d]))</code></pre><p>This constructs the pairs</p><pre><code class="nohighlight hljs">AsTable(nms) =&gt; ByRow(sum) =&gt; :c</code></pre><p><code>AsTable</code> on the right-hand side also allows the use of the special column selectors <code>Not</code>, <code>Between</code>, and regular expressions. For example, to calculate the product of all the columns beginning with the letter <code>&quot;a&quot;</code>, write</p><pre><code class="nohighlight hljs">@byrow :d = prod(AsTable(r&quot;^a&quot;))</code></pre><p><code>@transform!</code> accepts the same keyword arguments as <code>DataFrames.transform!</code> and can be added in two ways. When inputs are given as multiple arguments, they are added at the end after a semi-colon <code>;</code>, as in</p><pre><code class="nohighlight hljs">@transform!(gd, :x = :a .- 1; ungroup = false)</code></pre><p>When inputs are given in &quot;block&quot; format, the last lines may be written <code>@kwarg key = value</code>, which indicates keyword arguments to be passed to <code>transform!</code> function.</p><pre><code class="nohighlight hljs">@transform! gd begin
    :x = :a .- 1
    @kwarg ungroup = false
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(A = 1:3, B = [2, 1, 2]);

julia&gt; df2 = @transform!(df, :a = 2 * :A, :x = :A .+ :B)
3×4 DataFrame
 Row │ A      B      a      x
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      2      3
   2 │     2      1      4      3
   3 │     3      2      6      5

julia&gt; df === df2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1657-L1757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@transform-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@transform-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@transform</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@transform(d, i...; kwargs...)</code></pre><p>Add additional columns or keys based on keyword-like arguments.</p><p><strong>Arguments</strong></p><ul><li><code>d</code>: an <code>AbstractDataFrame</code>, or <code>GroupedDataFrame</code></li><li><code>i...</code>: transformations defining new columns or keys, of the form <code>:y = f(:x)</code></li><li><code>kwargs...</code>: keyword arguments passed to <code>DataFrames.transform</code></li></ul><p><strong>Returns</strong></p><ul><li><code>::AbstractDataFrame</code> or <code>::GroupedDataFrame</code></li></ul><p><strong>Details</strong></p><p>Inputs to <code>@transform</code> can come in two formats: a <code>begin ... end</code> block, in which case each line in the block is a separate transformation, (<code>:y = f(:x)</code>), or as a series of keyword-like arguments. For example, the following are equivalent:</p><pre><code class="language-julia hljs">@transform df begin
    :a = :x
    :b = :y
end</code></pre><p>and</p><pre><code class="nohighlight hljs">@transform(df, :a = :x, :b = :y)</code></pre><p><code>@transform</code> uses the syntax <code>@byrow</code> to wrap transformations in the <code>ByRow</code> function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call</p><pre><code class="nohighlight hljs">@transform(df, @byrow :y = :x == 1 ? true : false)</code></pre><p>becomes</p><pre><code class="nohighlight hljs">transform(df, :x =&gt; ByRow(x -&gt; x == 1 ? true : false) =&gt; :y)</code></pre><p>a transformation which cannot be conveniently expressed using broadcasting.</p><p>To avoid writing <code>@byrow</code> multiple times when performing multiple transformations by row, <code>@transform</code> allows <code>@byrow</code> at the beginning of a block of transformations (i.e. <code>@byrow begin... end</code>). All transformations in the block will operate by row.</p><p>Transformations can also use the macro-flag <a href="#DataFramesMeta.@astable-Tuple"><code>@astable</code></a> for creating multiple new columns at once and letting transformations share the same name-space. See <code>? @astable</code> for more details.</p><p>In operations, it is also allowed to use <code>AsTable(cols)</code> to work with multiple columns at once, where the columns are grouped together in a <code>NamedTuple</code>. When <code>AsTable(cols)</code> appears in a operation, no other columns may be referenced in the block.</p><p>Using <code>AsTable</code> in this way is useful for working with many columns at once programmatically. For example, to compute the row-wise sum of the columns <code>[:a, :b, :c, :d]</code>, write</p><pre><code class="nohighlight hljs">@byrow :c = sum(AsTable([:a, :b, :c, :d]))</code></pre><p>This constructs the pairs</p><pre><code class="nohighlight hljs">AsTable(nms) =&gt; ByRow(sum) =&gt; :c</code></pre><p><code>AsTable</code> on the right-hand side also allows the use of the special column selectors <code>Not</code>, <code>Between</code>, and regular expressions. For example, to calculate the product of all the columns beginning with the letter <code>&quot;a&quot;</code>, write</p><pre><code class="nohighlight hljs">@byrow :d = prod(AsTable(r&quot;^a&quot;))</code></pre><p><code>@transform</code> accepts the same keyword arguments as <code>DataFrames.transform!</code> and can be added in two ways. When inputs are given as multiple arguments, they are added at the end after a semi-colon <code>;</code>, as in</p><pre><code class="nohighlight hljs">@transform(gd, :x = :a .- 1; ungroup = false)</code></pre><p>When inputs are given in &quot;block&quot; format, the last lines may be written <code>@kwarg key = value</code>, which indicates keyword arguments to be passed to <code>transform!</code> function.</p><pre><code class="nohighlight hljs">@transform gd begin
    :x = :a .- 1
    @kwarg ungroup = false
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; df = DataFrame(A = 1:3, B = [2, 1, 2]);

julia&gt; @transform df begin
           :a = 2 * :A
           :x = :A .+ :B
       end
3×4 DataFrame
 Row │ A      B      a      x
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      2      3
   2 │     2      1      4      3
   3 │     3      2      6      5

julia&gt; @transform df @byrow :z = :A * :B
3×3 DataFrame
 Row │ A      B      z
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      2      2
   2 │     2      1      2
   3 │     3      2      6

julia&gt; @transform df @byrow begin
           :x = :A * :B
           :y = :A == 1 ? 100 : 200
       end
3×4 DataFrame
 Row │ A      B      x      y
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────
   1 │     1      2      2    100
   2 │     2      1      2    200
   3 │     3      2      6    200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1470-L1590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@where-Tuple{Any, Vararg{Any}}" href="#DataFramesMeta.@where-Tuple{Any, Vararg{Any}}"><code>DataFramesMeta.@where</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@where(x, args...)</code></pre><p>Deprecated version of <code>@subset</code>, see <code>?@subset</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L1016-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataFramesMeta.@with-Tuple{Any, Any}" href="#DataFramesMeta.@with-Tuple{Any, Any}"><code>DataFramesMeta.@with</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@with(d, expr)</code></pre><p><code>@with</code> allows DataFrame columns keys to be referenced as symbols.</p><p><strong>Arguments</strong></p><ul><li><code>d</code> : an AbstractDataFrame type</li><li><code>expr</code> : the expression to evaluate in <code>d</code></li></ul><p><strong>Details</strong></p><p><code>@with</code> works by parsing the expression body for all columns indicated by symbols (e.g. <code>:colA</code>). Then, a function is created that wraps the body and passes the columns as function arguments. This function is then called. Operations are efficient because:</p><ul><li>A pseudo-anonymous function is defined, so types are stable.</li><li>Columns are passed as references, eliminating DataFrame indexing.</li></ul><p>The following</p><pre><code class="language-julia hljs">@with(d, :a .+ :b .+ 1)</code></pre><p>becomes</p><pre><code class="language-julia hljs">tempfun(a, b) = a .+ b .+ 1
tempfun(d[!, :a], d[!, :b])</code></pre><p>If an expression is wrapped in <code>^(expr)</code>, <code>expr</code> gets passed through untouched. If an expression is wrapped in  <code>$(expr)</code>, the column is referenced by the variable <code>expr</code> rather than a symbol.</p><p>If the expression provide to <code>@with</code> begins with <code>@byrow</code>, the function created by the <code>@with</code> block is broadcasted along the columns of the data frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DataFramesMeta

julia&gt; y = 3;

julia&gt; df = DataFrame(x = 1:3, y = [2, 1, 2]);

julia&gt; x = [2, 1, 0];

julia&gt; @with(df, :y .+ 1)
3-element Vector{Int64}:
 3
 2
 3

julia&gt; @with(df, :x + x)
3-element Vector{Int64}:
 3
 3
 3

julia&gt; @with df begin
            res = 0.0
            for i in 1:length(:x)
                res += :x[i] * :y[i]
            end
            res
        end
10.0

julia&gt; @with(df, df[:x .&gt; 1, ^(:y)]) # The ^ means leave the :y alone
2-element Vector{Int64}:
 1
 2

julia&gt; colref = :x;

julia&gt; @with(df, :y + $colref) # Equivalent to df[!, :y] + df[!, colref]
3-element Vector{Int64}:
 3
 3
 5

julia&gt; @with df @byrow :x * :y
3-element Vector{Int64}:
 2
 2
 6
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@with</code> creates a function, so the scope within <code>@with</code> is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the <code>global</code> keyword. If the parent scope is a local scope (inside a function or let block for example), the <code>global</code> keyword is not needed to assign to that parent scope.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Using <code>AsTable</code> inside <code>@with</code> block is currently not supported.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/4f482da02d537da1624d58d2a6338916dcc22c2c/src/macros.jl#L557-L661">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../dplyr/">« Tutorial for coming from dplyr</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 1 March 2024 15:46">Friday 1 March 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
