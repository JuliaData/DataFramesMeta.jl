var documenterSearchIndex = {"docs":
[{"location":"dplyr/#DataFramesMeta.jl-Tutorial","page":"Tutorial for coming from dplyr","title":"DataFramesMeta.jl Tutorial","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"This is a port of the HarvardX series PH525x Genomics class tutorial on dplyr. View the original here and the source here.","category":"page"},{"location":"dplyr/#What-is-DataFramesMeta.jl?","page":"Tutorial for coming from dplyr","title":"What is DataFramesMeta.jl?","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"DataFramesMeta.jl is a Julia package to transform and summarize tabular data. It uses Julia macros to create a domain-specific language for convenient syntax to work with data frames from DataFrames.jl. DataFramesMeta.jl mirrors concepts in DataFrames.jl as closely as possible, without implementing new features on it's own. For a deeper explanation of DataFramesMeta.jl, see the documentation. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"DataFramesMeta.jl is heavily inspired by R's dplyr. If you are familiar with dplyr this guide should get you up to speed with DataFramesMeta.jl. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"However this tutorial assumes a cursory knowledge of DataFrames.jl. For instance, you should be familiar with the concept of a symbol in Julia (:x), and how it is used to index a data frame in DataFrames.jl, such as with df[:, :x]. ","category":"page"},{"location":"dplyr/#Why-Is-It-Useful?","page":"Tutorial for coming from dplyr","title":"Why Is It Useful?","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Like dplyr, the DataFramesMeta.jl package contains a set of macros (or \"verbs\") that perform common data manipulation operations such as filtering for rows, selecting specific columns, re-ordering rows, and adding new columns. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"In addition, DataFramesMeta.jl makes it easier to summarize data with the @combine verb, which implements the split-apply-combine pattern commonly seen in dplyr and other data manipulation packages.","category":"page"},{"location":"dplyr/#How-Does-It-Compare-To-Using-Base-Functions-in-Julia-and-in-DataFrames.jl?","page":"Tutorial for coming from dplyr","title":"How Does It Compare To Using Base Functions in Julia and in DataFrames.jl?","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"If you are familiar with Julia, you are probably familiar with base Julia functions such  map, and broadcast (akin to *apply in R). These functions are convenient to use, but are designed to work with arrays, not tabular data.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"DataFrames.jl provides the functions select, transform, and more to work with data frames. Unlike map and broadcast, these functions are designed to work with tabular data, but have a complicated syntax. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"DataFramesMeta.jl provides a convenient syntax for working with the vectors in a data frame so that you get all the convenience of Base Julia and DataFrames combined. ","category":"page"},{"location":"dplyr/#How-Do-I-Get-DataFramesMeta.jl?","page":"Tutorial for coming from dplyr","title":"How Do I Get DataFramesMeta.jl?","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"To install DataFramesMeta.jl, which also installs DataFrames.jl:","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"import Pkg\nPkg.activate(; temp=true) # activate a temprary environment for this tutorial\nPkg.add(\"DataFramesMeta\");","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"To load DataFramesMeta.jl, which also loads DataFrames.jl:","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"using DataFramesMeta","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"For this tutorial, we will install some additional packages as well. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Pkg.add([\"CSV\", \"HTTP\"])","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Now we load them. We also load the Statistics standard library, which is shipped with Julia, so does not need to be installed.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"using CSV, HTTP, Statistics","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"We will use CSV.jl and HTTP.jl for downloading our dataset from the internet.","category":"page"},{"location":"dplyr/#Data:-Mammals-Sleep","page":"Tutorial for coming from dplyr","title":"Data: Mammals Sleep","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"The msleep (mammals sleep) data set contains the sleep times and weights for a set of mammals and is available in the dagdata repository on GitHub. This data set contains 83 rows and 11 variables.  ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"We can load the data directly into a DataFrame from the url. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"url = \"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/msleep_ggplot2.csv\"\nmsleep = CSV.read(HTTP.get(url).body, DataFrame; missingstring=\"NA\")","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"The columns (in order) correspond to the following: ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"column name Description\n:name common name\n:genus taxonomic rank\n:vore carnivore, omnivore or herbivore?\n:order taxonomic rank\n:conservation the conservation status of the mammal\n:sleep_total total amount of sleep, in hours\n:sleep_rem rem sleep, in hours\n:sleep_cycle length of sleep cycle, in hours\n:awake amount of time spent awake, in hours\n:brainwt brain weight in kilograms\n:bodywt body weight in kilograms","category":"page"},{"location":"dplyr/#Important-DataFramesMeta.jl-Verbs-To-Remember","page":"Tutorial for coming from dplyr","title":"Important DataFramesMeta.jl Verbs To Remember","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Many DataFrames.jl macros come in two forms, a version which operates on columns as a whole and a version which operations row-wise, prefixed by r.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"DataFramesMeta.jl macro By-row version Description dplyr equivalent\n@select @rselect select columns select\n@transform @rtransform create new columns mutate\n@subset @rsubset filter rows filter\n@orderby @rorderby re-order or arrange rows arrange\n@combine  summarise values summarize (but @combine is more flexible)\ngroupby  allows for group operations in the \"split-apply-combine\" concept group_by","category":"page"},{"location":"dplyr/#DataFramesMeta.jl-Verbs-In-Action","page":"Tutorial for coming from dplyr","title":"DataFramesMeta.jl Verbs In Action","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Two of the most basic functions are @select and @subset, which selects columns and filters rows respectively. To reference columns, use the Symbol of the column name, i.e. :name refers to the column msleep.name.","category":"page"},{"location":"dplyr/#Selecting-Columns-Using-@select","page":"Tutorial for coming from dplyr","title":"Selecting Columns Using @select","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Select a set of columns: the :name and the :sleep_total columns. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@select msleep :name :sleep_total","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"If you have a column name stored as a variable, you can select it as a column with the syntax $. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"varname = :sleep_total\n@select msleep :name $varname","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"The $ sign has special meaning in DataFramesMeta.jl. We use it for any column reference which is not a symbol. Without it, DataFramesMeta.jl can't tell whether varname refers to the column :sleep_total. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"You can also use $ to refer to columns with strings","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"varname = \"sleep_total\"\n@select msleep :name $varname","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"as well as vectors of variable names ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"varnames = [\"name\", \"sleep_total\"]\n@select msleep $varnames","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Similarly, to select the first column, use the syntax $1. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@select msleep $1","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"To select all the columns except a specific column, use the Not function for inverse selection. We also need to wrap Not in the $ sign, because it is not a symbol. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@select msleep $(Not(:name))","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"To select a range of columns by name, use the Between operator:","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@select msleep $(Between(:name, :order))","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"To select all columns that start with the character string \"sl\" use regular expressions:","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@select msleep $(r\"^sl\")","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Regular expressions are powerful, but can be difficult for new users to understand. Here are some quick tips.  ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"r\"^abc\" = Starts with \"abc\"\nr\"abc$\" = Ends with \"abc\"\nr\"abc\" = Contains \"abc\" anywhere. ","category":"page"},{"location":"dplyr/#Selecting-Rows-Using-@subset-and-@rsubset","page":"Tutorial for coming from dplyr","title":"Selecting Rows Using @subset and @rsubset","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Filter the rows for mammals that sleep a total of more than 16 hours. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@subset msleep :sleep_total .>= 16","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"In the above expression, the .>= means we \"broadcast\" the >= comparison across the whole column. We can use a simpler syntax, @rsubset which automatically broadcasts all operations.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@rsubset msleep :sleep_total > 16","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Subset the rows for mammals that sleep a total of more than 16 hours and have a body weight of greater than 1 kilogram. For this we put multiple operations on separate lines in a single block. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@rsubset msleep begin \n    :sleep_total >= 16 \n    :bodywt >= 1\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"If you are coming from dplyr, you can also write the above command in a way that looks more familiar. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@rsubset(msleep, :sleep_total >= 16, :bodywt >= 1)","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Filter the rows for mammals in the Perissodactyla and Primates taxonomic order. We wrap code in a let block to ensure things are fast.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"let\n    relevant_orders = Set([\"Perissodactyla\", \"Primates\"])\n    @rsubset msleep :order in relevant_orders\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"You can use the boolean operators (e.g. >, <, >=, <=, !=, in) to create the logical tests. ","category":"page"},{"location":"dplyr/#Chain.jl","page":"Tutorial for coming from dplyr","title":"Chain.jl","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Before we go any further, let's introduce the @chain macro from Chain.jl, which is re-exported by DataFramesMeta.jl. @chain allows for you to pipe the output from one operation into the input of another operation.  The idea of piping is to read the functions from left to right. The syntax and design of @chain is very similar to %>% which users of dplyr are familiar with.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"To show it's usefulness, let's use @select and @rsubset one after the other. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"msleep_1 = @select msleep :name :sleep_total\nmsleep_2 = @rsubset msleep_1 :sleep_total > 16","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Now in this case, we will pipe the msleep data frame to the function that will select two columns (:name and :sleep_total) and then pipe the new data frame to the @rsubset opertaion. This method involves awkwardly creating and naming temporary data frames. We can avoid this with @chain.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@chain msleep begin \n    @select :name :sleep_total\n    @rsubset :sleep_total > 16\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"You will soon see how useful the @chain macro is when we start to combine many functions.  ","category":"page"},{"location":"dplyr/#Back-To-dplyr-Verbs-In-Action","page":"Tutorial for coming from dplyr","title":"Back To dplyr Verbs In Action","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Now that you know about the @chain macro, we will use it throughout the rest of this tutorial. ","category":"page"},{"location":"dplyr/#Arrange-Or-Re-order-Rows-Using-@orderby","page":"Tutorial for coming from dplyr","title":"Arrange Or Re-order Rows Using @orderby","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"To arrange (or re-order) rows by a particular column, such as the taxonomic order, list the name of the column you want to arrange the rows by:","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@orderby msleep :order","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Now we will select three columns from msleep, arrange the rows by the taxonomic order and then arrange the rows by :sleep_total. Finally, keep the first 10 rows of the data frame.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@chain msleep begin \n    @select :name :order :sleep_total\n    @orderby :order :sleep_total\n    first(10)\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"The last line of the above block, first(10), does not have @. This is because first is a Julia function, not a macro, whose names always begin with @. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Same as above, except here we filter the rows for mammals that sleep for 16 or more hours, instead of showing the head of the final data frame:","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@chain msleep begin \n    @select :name :order :sleep_total\n    @orderby :order :sleep_total \n    @rsubset :sleep_total > 16\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Something slightly more complicated: same as above, except arrange the rows in the :sleep_total column in a descending order. For this, use the function sortperm with the keyword argument rev=true.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@chain msleep begin \n    @select :name :order :sleep_total\n    @orderby begin \n        :order \n        sortperm(:sleep_total, rev=true)\n    end \n    @rsubset :sleep_total >= 16\nend","category":"page"},{"location":"dplyr/#Create-New-Columns-Using-@transform-and-@rtransform","page":"Tutorial for coming from dplyr","title":"Create New Columns Using @transform and @rtransform","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"The @transform macro will add new columns to the data frame. Like with other macros, use @rtransform to operate row-wise. Create a new column called :rem_proportion, which is the ratio of rem sleep to total amount of sleep. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@rtransform msleep :rem_proportion = :sleep_rem / :sleep_total","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"You can many new columns using @transform by placing multiple operations in a block.","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@rtransform msleep begin \n    :rem_proportion = :sleep_rem / :sleep_total \n    :bodywt_grams = :bodywt * 1000\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Using @transform instead of @rtransform will let us work with the column as a whole, and not a single row at a time. Let's create a new variable showing how far an animal's sleep time is from the average of all animals. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@transform msleep :demeand_sleep = :sleep_total .- mean(:sleep_total)","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Finally, note that you can create a new column with the name taken from an existing variable, or a new column name with spaces in it, with $","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"newname = :rem_proportion\n@rtransform msleep begin \n    $newname = :sleep_rem / :sleep_total\n    $\"Body weight in grams\" = :bodywt * 1000\nend","category":"page"},{"location":"dplyr/#Create-Summaries-of-the-Data-Frame-using-@combine","page":"Tutorial for coming from dplyr","title":"Create Summaries of the Data Frame using @combine","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"The @combine macro will create summary statistics for a given column in the data frame, such as finding the mean. For example, to compute the average number of hours of sleep, apply the mean function to the column :sleep_total and call the summary value :avg_sleep. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@chain msleep @combine :avg_sleep = mean(:sleep_total)","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"There are many other summary statistics you could consider such std, minimum, maximum, median, sum, length (returns the length of vector), first (returns first value in vector), and last (returns last value in vector).","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@combine msleep begin \n    :avg_sleep = mean(:sleep_total) \n    :min_sleep = minimum(:sleep_total)\n    :max_sleep = maximum(:sleep_total)\n    :total = length(:sleep_total)\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"DataFrames.jl also provides the function describe which performs many of these summaries automatically. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"describe(msleep)","category":"page"},{"location":"dplyr/#Group-Operations-using-groupby-and-@combine","page":"Tutorial for coming from dplyr","title":"Group Operations using groupby and @combine","text":"","category":"section"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"The groupby verb is an important function in DataFrames.jl (it does not live in DataFramesMeta.jl). As we mentioned before it's related to concept of \"split-apply-combine\". We literally want to split the data frame by some variable (e.g. taxonomic order), apply a function to the individual data frames and then combine the output.   ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Let's do that: split the msleep data frame by the taxonomic order, then ask for the same summary statistics as above. We expect a set of summary statistics for each taxonomic order. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@chain msleep begin \n    groupby(:order)\n    @combine begin \n        :avg_sleep = mean(:sleep_total)\n        :min_sleep = minimum(:sleep_total)\n        :max_sleep = maximum(:sleep_total)\n        :total = length(:sleep_total)\n    end\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"Split-apply-combine can also be used with @transform to add new variables to a data frame by performing operations by group. For instance, we can de-mean the total hours of sleep of an animal relative to other animals in the same genus. ","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"@chain msleep begin \n    groupby(:order)\n    @transform :sleep_genus = :sleep_total .- mean(:sleep_total)\nend","category":"page"},{"location":"dplyr/","page":"Tutorial for coming from dplyr","title":"Tutorial for coming from dplyr","text":"This short tutorial only touches on the wide array of features in Julia, DataFrames.jl, and DataFramesMeta.jl. Read the full documentation for more information.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Metaprogramming tools for DataFrames.jl objects to provide more convenient syntax.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl has the functions select, transform, and combine, as well as the in-place select! and transform! for manipulating data frames. DataFramesMeta.jl provides the macros  @select, @transform, @combine, @select!, and @transform! to mirror these functions with  more convenient syntax. Inspired by dplyr in R  and LINQ in C#. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition, DataFramesMeta provides ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@orderby, for sorting data frames\n@subset and @subset!, for keeping rows of a data frame matching a given condition\nRow-wise versions of the above macros in the form of @rtransform, @rtransform!, @rselect, @rselect!, @rorderby, @rsubset, and @rsubset!.\n@by, for grouping and combining a data frame in a single step\n@with, for working with the columns of a data frame with high performance and  convenient syntax\n@eachrow and @eachrow! for looping through rows in data frame, again with high performance and  convenient syntax. \n@byrow for applying functions to each row of a data frame (only supported inside other macros).\n@passmissing for propagating missing values inside row-wise DataFramesMeta.jl transformations.\n@astable to create multiple columns within a single transformation.\n@chain, from Chain.jl for piping the above macros together, similar to magrittr's %>% in R. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See below the convenience of DataFramesMeta compared to DataFrames.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(a = [1, 2], b = [3, 4]);\n\n# With DataFrames\ntransform(df, [:a, :b] => ((a, b) -> a .* b .+ first(a) .- sum(b)) => :c);\n\n# With DataFramesMeta\n@transform(df, :c = :a .* :b .+ first(:a) .- sum(:b))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To reference columns inside DataFramesMeta macros, use Symbols. For example, use :x to refer to the column df.x. To use a variable varname representing a Symbol to refer to  a column, use the syntax $varname. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Use passmissing  to propagate missing values more easily. See ?passmissing for  details. passmissing is defined in Missings.jl but exported by DataFramesMeta for convenience. ","category":"page"},{"location":"#Provided-macros","page":"Introduction","title":"Provided macros","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nNewer versions of DataFrames.jl support the operators Between, All, Cols, and Not when selecting and transforming columns. DataFramesMeta does not currently support this syntax. ","category":"page"},{"location":"#@select-and-@select!","page":"Introduction","title":"@select and @select!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Column selections and transformations. Only newly created columns are kept.  Operates on both a DataFrame and a GroupedDataFrame. Transformations are  called with the keyword-like syntax :y = f(:x). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@select returns a new data frame with newly allocated columns, while @select! mutates the original data frame and returns it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When given a GroupedDataFrame, performs a transformation by group and then  if necessary repeats the result to have as many rows as the input  data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@select(df, :x, :y)\n@select(df, :x2 = 2 * :x, :y)\n@select(gd, :x2 = 2 .* :y .* first(:y))\n@select!(df, :x, :y)\n@select!(df, :x = 2 * :x, :y)\n@select!(gd, :y = 2 .* :y .* first(:y))","category":"page"},{"location":"#@transform-and-@transform!","page":"Introduction","title":"@transform and @transform!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Add additional columns based on keyword-like arguments. Operates on both a  DataFrame and a GroupedDataFrame. Transformations are  called with the keyword-like syntax :y = f(:x). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform returns a new data frame with newly allocated columns, while @transform! mutates the original data frame and returns it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When given a GroupedDataFrame, performs a transformation by group and then  if necessary repeats the result to have as many rows as the input  data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@transform(df, :x2 = 2 * :x, :y)\n@transform(gd, :x2 = 2 .* :y .* first(:y))\n@transform!(df, :x, :y)\n@transform!(df, :x = 2 * :x, :y)\n@transform!(gd, :y = 2 .* :y .* first(:y))","category":"page"},{"location":"#@subset-and-@subset!","page":"Introduction","title":"@subset and @subset!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Select row subsets. Operates on both a DataFrame and a GroupedDataFrame.  @subset always returns a freshly-allocated data frame whereas  @subset! modifies the data frame in-place.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Statistics\ndf = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\noutside_var = 1;\n@subset(df, :x .> 1)\n@subset(df, :x .> outside_var)\n@subset(df, :x .> outside_var, :y .< 102)  # the two expressions are \"and-ed\"\n@subset(gd, :x .> mean(:x))","category":"page"},{"location":"#@combine","page":"Introduction","title":"@combine","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Summarize, or collapse, a grouped data frame by performing transformations at the group level and  collecting the result into a single data frame. Also works on a DataFrame, which  acts like a GroupedDataFrame with one group. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Like @select and @transform, transformations are called with the keyword-like  syntax :y = f(:x). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Examples:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@combine(gd, :x2 = sum(:y))\n@combine(gd, :x2 = :y .- sum(:y))\n@combine(gd, $AsTable = (n1 = sum(:y), n2 = first(:y)))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The last example tells the underlying DataFrames.jl function combine  that the output should be a \"Table\" in the Tables.jl  sense. For more information, see the documentation for DataFrames.combine and  the section below on escaping column identifiers with $. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@combine requires a DataFrame or GroupedDataFrame as the first argument. This is unlike combine from DataFrames.jl, which can take a function as the first argument and a GroupedDataFrame as the second argument. For instance, @combine((a = sum(:x), b = sum(:y)), gd) will fail.  The following, however, will work.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@combine(gd, $AsTable = (a = sum(:x), b = sum(:y)))","category":"page"},{"location":"#@orderby","page":"Introduction","title":"@orderby","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Sort rows in a DataFrame by values in one of several columns or a  transformation of columns. Only operates on DataFrames and not GroupedDataFrames. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\n@orderby(df, -1 .* :x)\n@orderby(df, :x, :y .- mean(:y))","category":"page"},{"location":"#@with","page":"Introduction","title":"@with","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"@with creates a scope in which all symbols that appear are aliases for the columns in a DataFrame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = 1:3, y = [2, 1, 2])\nx = [2, 1, 0]\n\n@with(df, :y .+ 1)\n@with(df, :x + x)  # the two x's are different\n\nx = @with df begin\n    res = 0.0\n    for i in 1:length(:x)\n        res += :x[i] * :y[i]\n    end\n    res\nend\n\n@with(df, df[:x .> 1, ^(:y)]) # The ^ means leave the :y alone\n","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\n@with creates a function, so scope within @with is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the global keyword. If the parent scope is a local scope (inside a function or let block for example), the global keyword is not needed to assign to that parent scope.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nBecause @with creates a function, be careful with the use of return. function data_transform(df; returnearly = true)\n    if returnearly\n        @with df begin \n            z = :x + :y\n            return z\n        end\n    else \n        return [1, 2, 3]\n    end\n\n    return [4, 5, 6]\nendThe above function will return [4, 5, 6] because the return inside the @with applies to the anonymous function created by @with. Given that @eachrow (below) is implemented with @with, the same caveat applies to  @eachrow blocks. ","category":"page"},{"location":"#@eachrow-and-@eachrow!","page":"Introduction","title":"@eachrow and @eachrow!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Act on each row of a data frame. Includes support for control flow and begin end  blocks. Since the \"environment\" induced by @eachrow df is implicitly a  single row of df, one uses regular operators and comparisons instead of  their elementwise counterparts as in @with. Does not change the input data  frame argument.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow! is identical to @eachrow but acts on a data frame in-place, modifying the input.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\ndf2 = @eachrow df begin \n    :A = :B + 1\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow introduces a function scope, so a let block is required here to create  a scope to allow assignment of variables within @eachrow. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2], C = [-4,2,1])\nlet x = 0.0\n    @eachrow df begin\n        if :A < :B\n            x += :A * :C\n        end\n    end\n    x\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow also supports special syntax for allocating new columns to make @eachrow more useful for data transformations. The syntax @newcol :x::Vector{Int} allocates a new column :x with an Vector container with eltype Int. Here is an example where two new columns are added:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\ndf2 = @eachrow df begin\n    @newcol :colX::Vector{Float64}\n    @newcol :colY::Vector{Union{Int,Missing}}\n    :colX = :B == 2 ? pi * :A : :B\n    if :A > 1\n        :colY = :A * :B\n    else\n        :colY = missing\n    end\nend","category":"page"},{"location":"#Row-wise-transformations-with-@byrow-and-@rtransform/@rselect/etc.","page":"Introduction","title":"Row-wise transformations with @byrow and @rtransform/@rselect/etc.","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"@byrow provides a convenient syntax to apply operations by-row, without having to vectorize manually. Additionally, the macros @rtransform, @rtransform!, @rselect, @rselect!,  @rorderby, @rsubset, and @rsubset! use @byrow by default.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl provides the function wrapper ByRow. ByRow(f)(x, y) is roughly equivalent to f.(x, y). DataFramesMeta.jl allows users  to construct expressions using ByRow function wrapper with the  syntax @byrow or the row-wise macros @rtransform, etc.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@byrow is not a \"real\" macro and cannot be used outside of  DataFramesMeta.jl macros. However its behavior within DataFramesMeta.jl macros should be indistinguishable from externally defined macros.  Thought of as a macro @byrow accepts a single argument and  creates an anonymous function wrapped in ByRow.  For example,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform(df, @byrow :y = :x == 1 ? true : false)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"is equivalent to","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, :x => ByRow(x -> x == 1 ? true : false) => :y)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following macros accept @byrow:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform and @transform!, @select, @select!, and @combine.  @byrow can be used in the left hand side of expressions, e.g. @select(df, @byrow z = :x * :y). \n@subset, @subset! and @orderby, with syntax of the form @subset(df, @byrow :x > :y)\n@with, where the anonymous function created by @with is wrapped in ByRow, as in @with(df, @byrow :x * :y).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To avoid writing @byrow multiple times when performing multiple operations, it is allowed to use @byrow at the beginning of a block of  operations. All transformations in the block will operate by row.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> df = DataFrame(a = [1, 2], b = [3, 4]);\n\njulia> @subset df @byrow begin\n           :a > 1\n           :b < 5\n       end\n1×2 DataFrame\n Row │ a      b     \n     │ Int64  Int64 \n─────┼──────────────\n   1 │     2      4","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@byrow can be used inside macros which accept GroupedDataFrames, however, like with ByRow in DataFrames.jl, when @byrow is used, functions do not take into account the grouping, so for example the result of @transform(df, @byrow :y = f(:x)) and  @transform(groupby(df, :g), @byrow :y = f(:x)) is the same.","category":"page"},{"location":"#Propagating-missing-values-with-@passmissing","page":"Introduction","title":"Propagating missing values with @passmissing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Many Julia functions do not automatically propagate missing values. For instance,  parse(Int, missing) will error. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Missings.jl provides the passmissing function-wrapper to help get around these roadblocks: passmissing(f)(args...) will return missing if any of args is missing. Similarly, DataFramesMeta.jl provides the @passmissing function to wrap the anonymous functions created by row-wise transformations in DataFramesMeta.jl  in Missings.passmissing.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The expression ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform df @byrow @passmissing :c = f(:a, :b)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"is translated to ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, [:a, :b] => ByRow(passmissing(f)) => :c)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See more examples below.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> no_missing(x::Int, y::Int) = x + y;\n\njulia> df = DataFrame(a = [1, 2, missing], b = [4, 5, 6])\n3×2 DataFrame\n Row │ a        b\n     │ Int64?   Int64\n─────┼────────────────\n   1 │       1      4\n   2 │       2      5\n   3 │ missing      6\n\njulia> @transform df @passmissing @byrow :c = no_missing(:a, :b)\n3×3 DataFrame\n Row │ a        b      c\n     │ Int64?   Int64  Int64?\n─────┼─────────────────────────\n   1 │       1      4        5\n   2 │       2      5        7\n   3 │ missing      6  missing\n\njulia> df = DataFrame(x_str = [\"1\", \"2\", missing])\n3×1 DataFrame\n Row │ x_str\n     │ String?\n─────┼─────────\n   1 │ 1\n   2 │ 2\n   3 │ missing\n\njulia> @rtransform df @passmissing :x = parse(Int, :x_str)\n3×2 DataFrame\n Row │ x_str    x\n     │ String?  Int64?\n─────┼──────────────────\n   1 │ 1              1\n   2 │ 2              2\n   3 │ missing  missing","category":"page"},{"location":"#Creating-multiple-columns-at-once-with-@astable","page":"Introduction","title":"Creating multiple columns at once with @astable","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Often new variables may depend on the same intermediate calculations. @astable makes it easy to create multiple new variables in the same operation, yet have them share information. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In a single block, all assignments of the form :y = f(:x)  or $y = f(:x) at the top-level generate new columns. In the second form, y must be a string or Symbol. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> df = DataFrame(a = [1, 2, 3], b = [400, 500, 600]);\n\njulia> @transform df @astable begin \n           ex = extrema(:b)\n           :b_first = :b .- first(ex)\n           :b_last = :b .- last(ex)\n       end\n3×4 DataFrame\n Row │ a      b      b_first  b_last \n     │ Int64  Int64  Int64    Int64  \n─────┼───────────────────────────────\n   1 │     1    400        0    -200\n   2 │     2    500      100    -100\n   3 │     3    600      200       0","category":"page"},{"location":"#Operations-with-multiple-columns-at-once-using-AsTable-inside-operations","page":"Introduction","title":"Operations with multiple columns at once using AsTable inside operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In operations, it is also allowed to use AsTable(cols) to work with multiple columns at once, where the columns are grouped together in a NamedTuple. When AsTable(cols) appears in a operation, no other columns may be referenced in the block.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"AsTable on the right-hand side also allows the use of the special column selectors Not, Between, and regular expressions, as well as working with lists of variables programmatically. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For example, consider a collection of column names vars, such that","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(a = [11, 14], b = [17, 10], c = [12, 5]);\nvars = [\"a\", \"b\"];","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To make a new column which is the sum of vars, write","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @rtransform df :y = sum(AsTable(vars))\n2×4 DataFrame\n Row │ a      b      c      y     \n     │ Int64  Int64  Int64  Int64 \n─────┼────────────────────────────\n   1 │    11     17     12     28\n   2 │    14     10      5     24","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Of course, you can also use AsTable on the right-hand side using Symbols as column selectors","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @rtransform df :y = sum(AsTable([:a, :b]))\n2×4 DataFrame\n Row │ a      b      c      y     \n     │ Int64  Int64  Int64  Int64 \n─────┼────────────────────────────\n   1 │    11     17     12     28\n   2 │    14     10      5     24","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"AsTable on the right-hand side also allows operations which can use the names of the variables. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> function fun_with_new_name(x::NamedTuple)\n           nms = string.(propertynames(x))\n           new_name = Symbol(join(nms, \"_\"), \"_sum\")\n           s = sum(x)\n           (; new_name => s)\n       end\n\njulia> @rtransform df $AsTable = fun_with_new_name(AsTable([:a, :b]))\n2×4 DataFrame\n Row │ a      b      c      a_b_sum \n     │ Int64  Int64  Int64  Int64   \n─────┼──────────────────────────────\n   1 │    11     17     12       28\n   2 │    14     10      5       24","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To subset all rows where the sum is greater than 25, write","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @rsubset df sum(AsTable(vars)) > 25\n1×3 DataFrame\n Row │ a      b      c     \n     │ Int64  Int64  Int64 \n─────┼─────────────────────\n   1 │    11     17     12","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To understand the how this works, recall that DataFrames.jl allows for AsTable(cols) to be a source in a source => fun => dest mini-language expression. As a consequence, the transformation call","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":":y = f(AsTable(cols)) ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"becomes","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"AsTable(cols) => f => :y","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that DataFrames does not allow source => fun => dest commands  to be of the form ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[AsTable(cols), :x] => f => :y","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As a consequence, DataFramesMeta.jl does not allow any other column selectors to appear  inside the expression. The command","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":":y = sum(AsTable(cols)) + :d","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will fail. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, note that everyting inside AsTable is escaped by default. There is no ned to use $ inside AsTable on the right-hand side. For example","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":":y = first(AsTable(\"a\"))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will work as expected.  ","category":"page"},{"location":"#AsTable-and-@astable,-explained","page":"Introduction","title":"AsTable and @astable, explained","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"At this point we have seen AsTable appear in three places:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"AsTable on the left-hand side of transformations: $AsTable = f(:a, :b)\nThe macro-flag @astable within the transformation. \nAsTable(cols) on the right-hand side for multi-column transformations. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The differences between the three is summarized below","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Operation Purpose Notes\n$AsTable on LHS Create multiple columns at once, whose column names are only known programmatically Requires escaping with $ until deprecation period ends for unquoted column names on LHS.\n@astable Create multiple columns at once where number of columns is known in advance \nAsTable on RHS Work with multiple columns at once Requires input columns, unlike on LHS","category":"page"},{"location":"#dollar","page":"Introduction","title":"Working with column names programmatically with $","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFramesMeta provides the special syntax $ for referring to  columns in a data frame via a Symbol, string, or column position as either a literal or a variable. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, :B = [2, 1, 2])\n\nnameA = :A\ndf2 = @transform(df, :C = :B - $nameA)\n\nnameA_string = \"A\"\ndf3 = @transform(df, :C = :B - $nameA_string)\n\nnameB = \"B\"\ndf4 = @eachrow df begin \n    :A = $nameB\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"$ can also be used to create new columns in a data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\n\nnewcol = \"C\"\n@select(df, $newcol = :A + :B)\n\n@by(df, :B, $(\"A complicated\" * \" new name\") = first(:A))\n\nnameC = \"C\"\ndf3 = @eachrow df begin \n    @newcol $nameC::Vector{Int}\n    $nameC = :A\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFramesMeta macros do not allow mixing of integer column references with references  of other types. This means @transform(df, :y = :A + $2), attempting to add the columns  df[!, :A] and df[!, 2], will fail. This is because in DataFrames, the command ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, [:A, 2] => (+) => :y)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will fail, as DataFrames requires the \"source\" column identifiers in a  source => fun => dest pair to all have the same type. DataFramesMeta adds one exception to this rule. Symbols and strings are allowed to be mixed inside DataFramesMeta macros.  Consequently, ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform(df, :y = :A + $\"B\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will not error even though ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, [:A, \"B\"] => (+) => :y)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will error in DataFrames. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For consistency, this restriction in the input column types also applies to @with and @eachrow. You cannot mix integer column references with Symbol or string column  references in @with and @eachrow in any part of the expression, but you can mix  Symbols and strings. The following will fail:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\n@eachrow df begin \n    :A = $2\nend\n\n@with df begin \n    $1 + $\"A\"\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"while the following will work without error","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow df begin \n    $1 + $2\nend\n\n@with df begin \n    $1 + $2\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To reference columns with more complicated expressions, you must wrap column references in parentheses. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform df :a + $(\"a column name\" * \" in two parts\")\n@transform df :a + $(get_column_name(x))","category":"page"},{"location":"#Using-src-fun-dest-calls-using","page":"Introduction","title":"Using src => fun => dest calls using $","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If an argument is entirely wrapped in $(), the result bypasses the anonymous function  creation of DataFramesMeta.jl and is passed to the underling DataFrames.jl function  directly. Importantly, this allows for src => fun => dest calls from the DataFrames.jl  \"mini-language\" directly. One example where this is useful is calling multiple functions across multiple input parameters. For instance, the Pair","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[:a, :b] .=> [sum mean]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"takes the sum and mean of both columns :a and :b separately. It is not possible to express this with DataFramesMeta.jl. But the operation can easily be performed with $","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Statistics\n\njulia> df = DataFrame(a = [1, 2], b = [30, 40]);\n\njulia> @transform df $([:a, :b] .=> [sum mean])\n2×6 DataFrame\n Row │ a      b      a_sum  b_sum  a_mean   b_mean  \n     │ Int64  Int64  Int64  Int64  Float64  Float64 \n─────┼──────────────────────────────────────────────\n   1 │     1     30      3     70      1.5     35.0\n   2 │     2     40      3     70      1.5     35.0","category":"page"},{"location":"#Multi-argument-column-selection","page":"Introduction","title":"Multi-argument column selection","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To refer to multiple columns in DataFrames.jl, one can write","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"select(df, [:a, :b])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"which selects the columns :a and :b in the data frame. We can generate this command in DataFramesMeta.jl with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@select df $[:a, :b]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Similarly, to select all columns beginning with the letter \"a\", wrap a regular expression in $(). As mentioned above, because the regex is a complicated syntax, we need to wrap it in parentheses, so that","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@select df $(r\"^a\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will construct the command select(df, r\"^a\"). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Multi-argument selectors may only be used when an entire argument is wrapped in $(). For example","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@select df :y = f($[:a, :b])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will fail. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Not all functions in DataFrames.jl allow for multi-column selectors, so detailed knowledge of the underlying functions in DataFrames.jl may be required. For example, the call ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"subset(df, [:a, :b])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will fail in DataFrames.jl, bcause DataFrames.subset does not support vectors of column names. Likewise, @subset df $[:a, :b] will fail. The macros which support multi-column selectors are ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@select\n@transform (multi-argument selectors have no effect)\n@combine\n@by","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Since arguments wrapped entirely in $() get passed directly to underlying DataFrames.jl functions, this allows the use of the DataFrames.jl \"mini-language\" consisting of src => fun => dest pairs inside DataFramesMeta.jl macros. For example, you can do the following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> df = DataFrame(a = [1, 2], b = [3, 4]);\n\njulia> my_transformation = :a => (t -> t .+ 100) => :c;\n\njulia> @transform df begin \n           $my_transformation\n           :d = :b .+ 200\n       end\n2×4 DataFrame\n Row │ a      b      c      d     \n     │ Int64  Int64  Int64  Int64 \n─────┼────────────────────────────\n   1 │     1      3    101    203\n   2 │     2      4    102    204","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or with @subset","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @subset df $(:a => t -> t .>= 2)\n1×2 DataFrame\n Row │ a      b     \n     │ Int64  Int64 \n─────┼──────────────\n   1 │     2      4","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe macros @orderby and @with do not transparently call underlying DataFrames.jl functions. Escaping entire transformations should be considered unstable and may change in future versions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nRow-wise macros such as @rtransform and @rsubset will not automatically wrap functions in src => fun => dest in ByRow. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In summary","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"All arguments that are not entirely escaped with $ or $() construct anonymous functions. Inside these expressions only single-column selectors are allowed. This includes\nSymbols, i.e. :x and :y\nStrings, escaped with $, i.e. $\"A string\" or $(\"A string with many\" * \"parts\")\nIntegers, escaped with $, i.e. $1\nAny single-column variable representing one of the above, escaped with $, i.e. $x\nIn transformation operations, i.e. @transform :y = f(:x), the same rules on the right hand side also apply to the left hand side. For example, @transform $\"y\" = f(:x) will work. \nArguments wrapped entirely in $ or $() are passed directly to the underlying DataFrames.jl functions. Because of this, in addition to the single-column selectors listed above, multi-argument selectors are allowed. These include, but are not limited to\nVectors of Symbols, $[:x, :y], strings, $[\"x\", \"y\"], or integers $[1, 2]\nRegular expressions, $(r\"^a\")\nFiltering column selectors, such as $(Not(:x)) and $(Between(:a, :z))\nThe macros @with, @subset, and @orderby do not support multi-column selectors. \nAdvanced users of DataFramesMeta.jl and DataFrames.jl may wrap an argument entirely in $() to pass src => fun => dest pairs directly to DataFrames.jl functions. However this is discouraged and it's behavior may change in future versions. ","category":"page"},{"location":"#Working-with-Symbols-without-referring-to-columns","page":"Introduction","title":"Working with Symbols without referring to columns","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To refer to Symbols without aliasing the column in a data frame, use ^. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\n@select(df, :x2 = :x, :x3 = ^(:x))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This rule applies to all DataFramesMeta macros.","category":"page"},{"location":"#Comparison-with-dplyr-and-LINQ","page":"Introduction","title":"Comparison with dplyr and LINQ","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A number of functions for operations on DataFrames have been defined. Here is a table of equivalents for Hadley's dplyr and common LINQ functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia             dplyr            LINQ\n---------------------------------------------\n@subset           filter           Where\n@transform        mutate           Select (?)\n@by                                GroupBy\ngroupby           group_by         GroupBy\n@combine          summarise/do\n@orderby          arrange          OrderBy\n@select           select           Select","category":"page"},{"location":"#Chaining-operations-together-with-@chain","page":"Introduction","title":"Chaining operations together with @chain","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To enable connecting multiple commands together in  a pipe, DataFramesMeta.jl re-exports the @chain macro from  Chain.jl. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Statistics \n\ndf = DataFrame(a = repeat(1:5, outer = 20),\n               b = repeat([\"a\", \"b\", \"c\", \"d\"], inner = 25),\n               x = repeat(1:20, inner = 5))\n\nx_thread = @chain df begin\n    @transform(:y = 10 * :x)\n    @subset(:a .> 2)\n    @by(:b, :meanX = mean(:x), :meanY = mean(:y))\n    @orderby(:meanX)\n    @select(:meanX, :meanY, :var = :b)\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"By default, @chain places the value of the  previous expression into the first argument of the current expression. The placeholder _ is used to break that convention and refer to the argument returned from the previous  expression.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# Get the sum of all columns after \n# a few transformations\n@chain df begin \n    @transform(:y = 10 .* :x)\n    @subset(:a .> 2)\n    @select(:a, :y, :x)\n    reduce(+, eachcol(_))\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@chain also provides the @aside macro-flag to perform operations in the middle of a @chain block. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@chain df begin \n    @transform :y = 10 .* :x\n    @aside y_mean = mean(_.y) # From Chain.jl, not DataFramesMeta.jl\n    @select :y_standardize = :y .- y_mean\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"api/api.md\"]\nDepth = 3","category":"page"},{"location":"api/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Modules = [DataFramesMeta]\nPrivate = false","category":"page"},{"location":"api/api/#DataFramesMeta.@astable-Tuple","page":"API","title":"DataFramesMeta.@astable","text":"@astable(args...)\n\nReturn a NamedTuple from a single transformation inside the DataFramesMeta.jl macros, @select, @transform, and their mutating and row-wise equivalents.\n\n@astable acts on a single block. It works through all top-level expressions and collects all such expressions of the form :y = ... or $y = ..., i.e. assignments to a Symbol or an escaped column identifier, which is a syntax error outside of DataFramesMeta.jl macros. At the end of the expression, all assignments are collected into a NamedTuple to be used with the AsTable destination in the DataFrames.jl transformation mini-language.\n\nConcretely, the expressions\n\ndf = DataFrame(a = 1)\n\n@rtransform df @astable begin\n    :x = 1\n    y = 50\n    :z = :x + y + :a\nend\n\nbecome the pair\n\nfunction f(a)\n    x_t = 1\n    y = 50\n    z_t = x_t + y + a\n\n    (; x = x_t, z = z_t)\nend\n\ntransform(df, [:a] => ByRow(f) => AsTable)\n\n@astable has two major advantages at the cost of increasing complexity. First, @astable makes it easy to create multiple columns from a single transformation, which share a scope. For example, @astable allows for the following (where :x and :x_2 exist in the data frame already).\n\n@transform df @astable begin\n    m = mean(:x)\n    :x_demeaned = :x .- m\n    :x2_demeaned = :x2 .- m\nend\n\nThe creation of :x_demeaned and :x2_demeaned both share the variable m, which does not need to be calculated twice.\n\nSecond, @astable is useful when performing intermediate calculations and storing their results in new columns. For example, the following fails.\n\n@rtransform df begin\n    :new_col_1 = :x + :y\n    :new_col_2 = :new_col_1 + :z\nend\n\nThis because DataFrames.jl does not guarantee sequential evaluation of transformations. @astable solves this problem\n\n@rtransform df @astable begin     :newcol1 = :x + :y     :newcol2 = :newcol1 + :z end\n\nColumn assignment in @astable follows similar rules as column assignment in other DataFramesMeta.jl macros. The left- -hand-side of a column assignment can be either a Symbol or any expression which evaluates to a Symbol or AbstractString. For example :y = ..., and $y = ... are both valid ways of assigning a new column. However unlike other DataFramesMeta.jl macros, multi-column assignments via AsTable are disallowed. The following will fail.\n\n@transform df @astable begin\n    AsTable = :x\nend\n\nReferences to existing columns also follow the same rules as other DataFramesMeta.jl macros.\n\nExamples\n\njulia> df = DataFrame(a = [1, 2, 3], b = [4, 5, 6]);\n\njulia> d = @rtransform df @astable begin\n           :x = 1\n           y = 5\n           :z = :x + y\n       end\n3×4 DataFrame\n Row │ a      b      x      z\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      1      6\n   2 │     2      5      1      6\n   3 │     3      6      1      6\n\njulia> df = DataFrame(a = [1, 1, 2, 2], b = [5, 6, 70, 80]);\n\njulia> @by df :a @astable begin\n            ex = extrema(:b)\n            :min_b = first(ex)\n            :max_b = last(ex)\n       end\n2×3 DataFrame\n Row │ a      min_b  max_b\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      5      6\n   2 │     2     70     80\n\njulia> new_col = \"New Column\";\n\njulia> @rtransform df @astable begin\n           f_a = first(:a)\n           $new_col = :a + :b + f_a\n           :y = :a * :b\n       end\n4×4 DataFrame\n Row │ a      b      New Column  y\n     │ Int64  Int64  Int64       Int64\n─────┼─────────────────────────────────\n   1 │     1      5           7      5\n   2 │     1      6           8      6\n   3 │     2     70          74    140\n   4 │     2     80          84    160\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@based_on-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@based_on","text":"@based_on(d, args...)\n\nDeprecated version of @combine, see: @combine\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@by-Tuple{Any, Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@by","text":"@by(d::AbstractDataFrame, cols, e...)\n\nSplit-apply-combine in one step.\n\nArguments\n\nd : an AbstractDataFrame\ncols : a column indicator (Symbol, Int, Vector{Symbol}, etc.)\ne :  keyword-like arguments, of the form :y = f(:x) specifying\n\nnew columns in terms of column groupings\n\nReturns\n\n::DataFrame\n\nTransformation inputs to @by can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation, or as a series of keyword-like arguments. For example, the following are equivalent:\n\n@by df :g begin\n    :mx = mean(:x)\n    :sx = std(:x)\nend\n\nand\n\n@by(df, :g, mx = mean(:x), sx = std(:x))\n\nTransformations can also use the macro-flag @astable for creating multiple new columns at once and letting transformations share the same name-space. See ? @astable for more details.\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(\n            a = repeat(1:4, outer = 2),\n            b = repeat(2:-1:1, outer = 4),\n            c = 1:8);\n\njulia> @by(df, :a, :d = sum(:c))\n4×2 DataFrame\n Row │ a      d\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      6\n   2 │     2      8\n   3 │     3     10\n   4 │     4     12\n\njulia> @by df :a begin\n           :d = 2 * :c\n       end\n8×2 DataFrame\n Row │ a      d\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     1     10\n   3 │     2      4\n   4 │     2     12\n   5 │     3      6\n   6 │     3     14\n   7 │     4      8\n   8 │     4     16\n\njulia> @by(df, :a, :c_sum = sum(:c), :c_mean = mean(:c))\n4×3 DataFrame\n Row │ a      c_sum  c_mean\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      6      3.0\n   2 │     2      8      4.0\n   3 │     3     10      5.0\n   4 │     4     12      6.0\n\njulia> @by df :a begin\n           :c = :c\n           :c_mean = mean(:c)\n       end\n8×3 DataFrame\n Row │ a      c      c_mean\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      1      3.0\n   2 │     1      5      3.0\n   3 │     2      2      4.0\n   4 │     2      6      4.0\n   5 │     3      3      5.0\n   6 │     3      7      5.0\n   7 │     4      4      6.0\n   8 │     4      8      6.0\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@byrow-Tuple","page":"API","title":"DataFramesMeta.@byrow","text":"@byrow\n\nBroadcast operations within DataFramesMeta.jl macros.\n\n@byrow is not a \"real\" Julia macro but rather serves as a \"flag\" to indicate that the anonymous function created by DataFramesMeta to represent an operation should be applied \"by-row\".\n\nIf an expression starts with @byrow, either of the form @byrow :y = f(:x) in transformations or @byrow f(:x) in @orderby, @subset, and @with, then the anonymous function created by DataFramesMeta is wrapped in the DataFrames.ByRow function wrapper, which broadcasts the function so that it run on each row.\n\nExamples\n\njulia> df = DataFrame(a = [1, 2, 3, 4], b = [5, 6, 7, 8]);\n\njulia> @transform(df, @byrow :c = :a * :b)\n4×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      5      5\n   2 │     2      6     12\n   3 │     3      7     21\n   4 │     4      8     32\n\njulia> @subset(df, @byrow :a == 1 ? true : false)\n1×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      5\n\nTo avoid writing @byrow multiple times when performing multiple operations, it is allowed to use @byrow at the beginning of a block of operations. All transformations in the block will operate by row.\n\njulia> @subset df @byrow begin\n           :a > 1\n           :b < 5\n       end\n1×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      4\n\nComparison with @eachrow\n\nTo re-cap, the @eachrow macro roughly transforms\n\n@eachrow df begin\n    :a * :b\nend\n\nto\n\nbegin\n    function tempfun(a, b)\n        for i in eachindex(a)\n            a[i] * b[i]\n        end\n    end\n    tempfun(df.a, df.b)\n    df\nend\n\nThe function * is applied by-row. But the result of those operations is not stored anywhere, as with for-loops in Base Julia. Rather, @eachrow and @eachrow! return data frames.\n\nNow consider @byrow. @byrow transforms\n\n@with df @byrow begin\n    :a * :b\nend\n\nto\n\ntempfun(a, b) = a * b\ntempfun.(df.a, df.b)\n\nIn contrast to @eachrow, @with combined with @byrow returns a vector of the broadcasted multiplication and not a data frame.\n\nAdditionally, transformations applied using @eachrow! modify the input data frame. On the contrary, @byrow does not update columns.\n\njulia> df = DataFrame(a = [1, 2], b = [3, 4]);\n\njulia> @with df @byrow begin\n           :a = 500\n       end\n2-element Vector{Int64}:\n 500\n 500\n\njulia> df\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\nComparison with @. and Base broadcasting\n\nBase Julia provides the broadasting macro @. and in many cases @. and @byrow will give equivalent results. But there are important deviations in behavior. Consider the setup\n\ndf = DataFrame(a = [1, 2], b = [3, 4])\n\nControl flow. @byrow allows for operations of the form if ... else and a ? b : c to be applied by row. These expressions cannot be broadcasted in Base Julia. @byrow also allows for expressions of the form a && b and a || b to be applied by row, something that is not possible in Julia versions below 1.7.\n\njulia> @with df @byrow begin\n           if :a == 1\n               5\n           else\n               10\n           end\n       end\n2-element Vector{Int64}:\n  5\n 10\n\njulia> @with df @. begin\n           if :a == 1\n               5\n           else\n               10\n           end\n       end # will error\n\nBroadcasting objects that are not columns. @byrow constructs an anonymous function which accepts only the columns of the input data frame and broadcasts that function. Consequently, it does not broadcast referenced objects which are not columns.\n\njulia> df = DataFrame(a = [1, 2], b = [3, 4]);\njulia> @with df @byrow :x + [5, 6]\n\nwill error, because the :x in the above expression refers   to a scalar Int, and you cannot do 1 + [5, 6].\n\nOn the other hand\n\n@with df @. :x + [5, 6]\n\nwill succeed, as df.x is a 2-element vector as is [5, 6].\n\nBecause ByRow inside transform blocks does not internally   use broadcasting in all circumstances, in the rare instance   that a column in a data frame is a custom vector type that   implements custom broadcasting, this custom behavior will   not be called with @byrow.\n\nBroadcasting expensive calls. In Base Julia, broadcasting evaluates calls first and then broadcasts the result. Because @byrow constructs an anonymous function and evaluates that function for every row in the data frame, expensive functions will be evaluated many times.\n\njulia> function expensive()\n           sleep(.5)\n           return 1\n       end;\n\njulia> @time @with df @byrow :a + expensive();\n  1.037073 seconds (51.67 k allocations: 3.035 MiB, 3.19% compilation time)\n\njulia> @time @with df :a .+ expensive();\n  0.539900 seconds (110.67 k allocations: 6.525 MiB, 7.05% compilation time)\n\n\nThis problem comes up when using the @. macro as well,   but can easily be fixed with $. Because $ is currently   reserved for escaping column references, no solution currently exists with   @byrow or in DataFramesMeta.jl at large. The best solution is simply\n\n@with df begin\n    x = expensive()\n    :a + x\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@combine-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@combine","text":"@combine(x, args...)\n\nSummarize a grouping operation\n\nArguments\n\nx : a GroupedDataFrame or AbstractDataFrame\nargs... : keyword-like arguments defining new columns, of the form :y = f(:x)\n\nInputs to @combine can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation, or as a series of keyword-like arguments. For example, the following are equivalent:\n\n@combine df begin\n    :mx = mean(:x)\n    :sx = std(:x)\nend\n\nand\n\n@combine(df, :mx = mean(:x), :sx = std(:x))\n\nTransformations can also use the macro-flag @astable for creating multiple new columns at once and letting transformations share the same name-space. See ? @astable for more details.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> d = DataFrame(\n            n = 1:20,\n            x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);\n\njulia> g = groupby(d, :x);\n\njulia> @combine(g, :nsum = sum(:n))\n3×2 DataFrame\n Row │ x      nsum\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     99\n   2 │     2     84\n   3 │     3     27\n\njulia> @combine g begin\n           :x2 = 2 * :x\n           :nsum = sum(:n)\n       end\n20×3 DataFrame\n Row │ x      x2     nsum\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2     99\n   2 │     1      2     99\n   3 │     1      2     99\n   4 │     1      2     99\n   5 │     1      2     99\n   6 │     1      2     99\n   7 │     1      2     99\n   8 │     1      2     99\n   9 │     1      2     99\n  10 │     2      4     84\n  11 │     2      4     84\n  12 │     2      4     84\n  13 │     2      4     84\n  14 │     2      4     84\n  15 │     2      4     84\n  16 │     3      6     27\n  17 │     3      6     27\n  18 │     3      6     27\n  19 │     3      6     27\n  20 │     3      6     27\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@eachrow!-Tuple{Any, Any}","page":"API","title":"DataFramesMeta.@eachrow!","text":"@eachrow!(df, body)\n\nAct on each row of a data frame in-place, similar to\n\nfor row in eachrow(df)\n    ... # Actions that modify `df`.\nend\n\nIncludes support for control flow and begin end blocks. Since the \"environment\" induced by @eachrow! df is implicitly a single row of df, use regular operators and comparisons instead of their elementwise counterparts as in @with. Note that the scope within @eachrow! is a hard scope.\n\neachrow! also supports special syntax for allocating new columns. The syntax @newcol x::Vector{Int} allocates a new uninitialized column :x with an Vector container with eltype Int.This feature makes it easier to use eachrow for data transformations. _N is introduced to represent the number of rows in the data frame, _DF represents the dataframe including added columns, and row represents the index of the current row.\n\nChanges to the rows directly affect df. The operation will modify the data frame in place. See @eachrow which employs the same syntax but allocates a fresh data frame.\n\nLike with @transform!, @eachrow! supports the use of $ to work with column names stored as variables. Using $ with a multi-column selector, such as a Vector of Symbols, is currently unsupported.\n\nArguments\n\ndf : an AbstractDataFrame\nexpr : expression operated on row by row\n\nReturns\n\nThe modified AbstractDataFrame.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> let x = 0\n            @eachrow! df begin\n                if :A + :B == 3\n                    x += 1\n                end\n            end  #  This doesn't work without the let\n            x\n        end\n2\n\njulia> df2 = copy(df);\n\njulia> @eachrow! df2 begin\n           if :A > :B\n               :A = 0\n           end\n       end;\n\njulia> df2\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     0      1\n   3 │     0      2\n\njulia> df2 = copy(df);\n\njulia> @eachrow! df2 begin\n           @newcol :colX::Vector{Float64}\n           :colX = :B == 2 ? pi * :A : :B\n       end\n3×3 DataFrame\n Row │ A      B      colX\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  3.14159\n   2 │     2      1  1.0\n   3 │     3      2  9.42478\n\njulia> varA = :A; varB = :B;\n\njulia> df2 = copy(df);\n\njulia> @eachrow! df2 begin\n           @newcol :colX::Vector{Float64}\n           :colX = $varB == 2 ? pi * $varA : $varB\n       end\n3×3 DataFrame\n Row │ A      B      colX\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  3.14159\n   2 │     2      1  1.0\n   3 │     3      2  9.42478\n\njulia> x = [1, 1, 1];\n\njulia> @eachrow! df begin\n           x[row] = :A\n       end;\n\njulia> x\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> @eachrow! df begin\n           @newcol :m::Vector{Float64}\n           :m = mean(_DF[:, row])\n       end\n3×3 DataFrame\n Row │ A      B      m\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  2.0\n   2 │     2      1  1.66667\n   3 │     3      2  1.22222\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@eachrow-Tuple{Any, Any}","page":"API","title":"DataFramesMeta.@eachrow","text":"@eachrow(df, body)\n\nAct on each row of a data frame, producing a new dataframe. Similar to\n\nfor row in eachrow(copy(df))\n    ...\nend\n\nIncludes support for control flow and begin end blocks. Since the \"environment\" induced by @eachrow df is implicitly a single row of df, use regular operators and comparisons instead of their elementwise counterparts as in @with. Note that the scope within @eachrow is a hard scope.\n\neachrow also supports special syntax for allocating new columns. The syntax @newcol x::Vector{Int} allocates a new uninitialized column :x with an Vector container with eltype Int.This feature makes it easier to use eachrow for data transformations. _N is introduced to represent the number of rows in the data frame, _DF represents the DataFrame including added columns, and row represents the index of the current row.\n\nChanges to the rows do not affect df but instead a freshly allocated data frame is returned by @eachrow. Also note that the returned data frame does not share columns with df. See @eachrow! which employs the same syntax but modifies the data frame in-place.\n\nLike with @transform, @eachrow supports the use of $ to work with column names stored as variables. Using $ with a multi-column selector, such as a Vector of Symbols, is currently unsupported.\n\nArguments\n\ndf : an AbstractDataFrame\nexpr : expression operated on row by row\n\nReturns\n\nThe modified AbstractDataFrame.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> let x = 0\n            @eachrow df begin\n                if :A + :B == 3\n                    x += 1\n                end\n            end  #  This doesn't work without the let\n            x\n        end\n2\n\njulia> @eachrow df begin\n            if :A > :B\n                :A = 0\n            end\n        end\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     0      1\n   3 │     0      2\n\njulia> df2 = @eachrow df begin\n           @newcol :colX::Vector{Float64}\n           :colX = :B == 2 ? pi * :A : :B\n       end\n3×3 DataFrame\n Row │ A      B      colX\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  3.14159\n   2 │     2      1  1.0\n   3 │     3      2  9.42478\n\njulia> varA = :A; varB = :B;\n\njulia> df2 = @eachrow df begin\n           @newcol :colX::Vector{Float64}\n           :colX = $varB == 2 ? pi * $varA : $varB\n       end\n3×3 DataFrame\n Row │ A      B      colX\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  3.14159\n   2 │     2      1  1.0\n   3 │     3      2  9.42478\n\njulia> x = [1, 1, 1];\n\njulia> @eachrow df begin\n           x[row] = :A\n       end;\n\njulia> x\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> @eachrow df begin\n           @newcol :m::Vector{Float64}\n           :m = mean(_DF[:, row])\n       end\n3×3 DataFrame\n Row │ A      B      m\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  2.0\n   2 │     2      1  1.66667\n   3 │     3      2  1.22222\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@linq-Tuple{Any}","page":"API","title":"DataFramesMeta.@linq","text":"@linq df ...\n\nnote: Note\n@linq is deprecated. Use @chain instead. See ? @chain for details.\n\nGeneral macro that creates a mini DSL for chaining and macro calls.\n\nDetails\n\nThe following embedded function calls are equivalent to their macro version:\n\nwith\nwhere\nselect\ntransform\nby\ngroupby\norderby\ncombine\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(\n            a = repeat(1:4, outer = 2),\n            b = repeat(2:-1:1, outer = 4),\n            x = 1:8);\n\njulia> x1 = @linq transform(where(df, :a .> 2, :b .!= \"c\"), :y = 10 .* :x);\n\njulia> x1 = @linq by(x1, :b, :meanX = mean(:x), :meanY = mean(:y));\n\njulia> @linq select(orderby(x1, :b, -:meanX), :var = :b, :meanX, :meanY)\n2×3 DataFrame\n│ Row │ var   │ meanX   │ meanY   │\n│     │ Int64 │ Float64 │ Float64 │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ 6.0     │ 60.0    │\n│ 2   │ 2     │ 5.0     │ 50.0    │\n\njulia> @linq df |>\n           transform(y = 10 .* :x) |>\n           where(:a .> 2) |>\n           by(:b, :meanX = mean(:x), :meanY = mean(:y)) |>\n           orderby(:meanX) |>\n           select(:meanX, :meanY, var = :b)\n2×3 DataFrame\n│ Row │ meanX   │ meanY   │ var   │\n│     │ Float64 │ Float64 │ Int64 │\n├─────┼─────────┼─────────┼───────┤\n│ 1   │ 5.0     │ 50.0    │ 2     │\n│ 2   │ 6.0     │ 60.0    │ 1     │\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@orderby-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@orderby","text":"@orderby(d, i...)\n\nSort rows by values in one of several columns or a transformation of columns. Always returns a fresh DataFrame. Does not accept a GroupedDataFrame.\n\nWhen given a DataFrame, @orderby applies the transformation given by its arguments (but does not create new columns) and sorts the given DataFrame on the result, returning a new DataFrame.\n\nInputs to @orderby can come in two formats: a begin ... end block, in which case each line in the block is a separate ordering operation, and as mulitple arguments. For example, the following two statements are equivalent:\n\n@orderby df begin\n    :x\n    -:y\nend\n\nand\n\n@orderby(df, :x, -:y)\n\nArguments\n\nd : an AbstractDataFrame\ni... : expression for sorting\n\nIf an expression provided to @orderby begins with @byrow, operations are applied \"by row\" along the data frame. To avoid writing @byrow multiple times, @orderby also allows @byrowto be placed at the beginning of a block of operations. For example, the following two statements are equivalent.\n\n@orderby df @byrow begin\n    :x^2\n    :x^3\nend\n\nand\n\n@orderby df\n    @byrow :x^2\n    @byrow :x^3\nend\n\nIn operations, it is also allowed to use AsTable(cols) to work with multiple columns at once, where the columns are grouped together in a NamedTuple. When AsTable(cols) appears in a operation, no other columns may be referenced in the block.\n\nUsing AsTable in this way is useful for working with many columns at once programmatically. For example, to order rows by the sum of the columns :a, :b, and :c, write\n\n@byrow sum(AsTable([:a, :b, :c]))\n\nThis constructs the pair\n\nAsTable([:a, :b, :c]) => ByRow(sum)\n\nAsTable on the right-hand side also allows the use of the special column selectors Not, Between, and regular expressions. For example, to order all rows by the product of all columns starting with \"a\", write\n\n@byrow prod(AsTable(r\"^a\"))\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> d = DataFrame(x = [3, 3, 3, 2, 1, 1, 1, 2, 1, 1], n = 1:10,\n                     c = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]);\n\njulia> @orderby(d, -1 .* :n)\n10×3 DataFrame\n Row │ x      n      c\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     1     10  j\n   2 │     1      9  i\n   3 │     2      8  h\n   4 │     1      7  g\n   5 │     1      6  f\n   6 │     1      5  e\n   7 │     2      4  d\n   8 │     3      3  c\n   9 │     3      2  b\n  10 │     3      1  a\n\njulia> @orderby(d, sortperm(:c, rev = true))\n10×3 DataFrame\n Row │ x      n      c\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     1     10  j\n   2 │     1      9  i\n   3 │     2      8  h\n   4 │     1      7  g\n   5 │     1      6  f\n   6 │     1      5  e\n   7 │     2      4  d\n   8 │     3      3  c\n   9 │     3      2  b\n  10 │     3      1  a\n\njulia> @orderby d begin\n           :x\n           abs.(:n .- mean(:n))\n       end\n10×3 DataFrame\n Row │ x      n      c\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     1      5  e\n   2 │     1      6  f\n   3 │     1      7  g\n   4 │     1      9  i\n   5 │     1     10  j\n   6 │     2      4  d\n   7 │     2      8  h\n   8 │     3      3  c\n   9 │     3      2  b\n  10 │     3      1  a\n\njulia> @orderby d @byrow :x^2\n10×3 DataFrame\n Row │ x      n      c\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     1      5  e\n   2 │     1      6  f\n   3 │     1      7  g\n   4 │     1      9  i\n   5 │     1     10  j\n   6 │     2      4  d\n   7 │     2      8  h\n   8 │     3      1  a\n   9 │     3      2  b\n  10 │     3      3  c\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@passmissing-Tuple","page":"API","title":"DataFramesMeta.@passmissing","text":"@passmissing(args...)\n\nPropagate missing values inside DataFramesMeta.jl macros.\n\n@passmissing is not a \"real\" Julia macro but rather serves as a \"flag\" to indicate that the anonymous function created by DataFramesMeta.jl to represent an operation should be wrapped in passmissing from Missings.jl.\n\n@passmissing can only be combined with @byrow or the row-wise versions of macros such as @rtransform and @rselect, etc. If any of the arguments passed to the row-wise anonymous function created by DataFramesMeta.jl with @byrow, the result will automatically be missing.\n\nIn the below example, @transform would throw an error without the @passmissing flag.\n\n@passmissing is especially useful for functions which operate on strings, such as parse.\n\nExamples\n\njulia> no_missing(x::Int, y::Int) = x + y;\n\njulia> df = DataFrame(a = [1, 2, missing], b = [4, 5, 6])\n3×2 DataFrame\n Row │ a        b\n     │ Int64?   Int64\n─────┼────────────────\n   1 │       1      4\n   2 │       2      5\n   3 │ missing      6\n\njulia> @transform df @passmissing @byrow c = no_missing(:a, :b)\n3×3 DataFrame\n Row │ a        b      c\n     │ Int64?   Int64  Int64?\n─────┼─────────────────────────\n   1 │       1      4        5\n   2 │       2      5        7\n   3 │ missing      6  missing\n\njulia> df = DataFrame(x_str = [\"1\", \"2\", missing])\n3×1 DataFrame\n Row │ x_str\n     │ String?\n─────┼─────────\n   1 │ 1\n   2 │ 2\n   3 │ missing\n\njulia> @rtransform df @passmissing x = parse(Int, :x_str)\n3×2 DataFrame\n Row │ x_str    x\n     │ String?  Int64?\n─────┼──────────────────\n   1 │ 1              1\n   2 │ 2              2\n   3 │ missing  missing\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rorderby-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@rorderby","text":"rorderby(d, args...)\n\nRow-wise version of @orderby, i.e. all operations use @byrow by default. See @orderby for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rselect!-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@rselect!","text":"@rselect!(x, args...)\n\nRow-wise version of @select!, i.e. all operations use @byrow by default. See @select! for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rselect-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@rselect","text":"@rselect(x, args...)\n\nRow-wise version of @select, i.e. all operations use @byrow by default. See @select for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rsubset!-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@rsubset!","text":"@rsubset!(d, i...)\n\nRow-wise version of @subset!, i.e. all operations use @byrow by default. See @subset! for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rsubset-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@rsubset","text":"@rsubset(d, i...)\n\nRow-wise version of @subset, i.e. all operations use @byrow by default. See @subset for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rtransform!-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@rtransform!","text":"@rtransform!(x, args...)\n\nRow-wise version of @transform!, i.e. all operations use @byrow by default. See @transform! for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rtransform-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@rtransform","text":"@rtransform(x, args...)\n\nRow-wise version of @transform, i.e. all operations use @byrow by default. See @transform for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@select!-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@select!","text":"@select!(d, e...)\n\nMutate d in-place to retain only columns or transformations specified by e and return it. No copies of existing columns are made.\n\nArguments\n\nd : an AbstractDataFrame\ne :  keyword-like arguments, of the form :y = f(:x) specifying\n\nnew columns in terms of existing columns or symbols to specify existing columns\n\nReturns\n\n::DataFrame\n\nInputs to @select! can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation or selector, or as a series of arguments and keyword-like arguments. For example, the following are equivalent:\n\n@select! uses the syntax @byrow to wrap transformations in the ByRow function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call\n\n@select!(df, @byrow :y = :x == 1 ? true : false)\n\nbecomes\n\nselect!(df, :x => ByRow(x -> x == 1 ? true : false) => :y)\n\na transformation which cannot be conveniently expressed using broadcasting.\n\nTo avoid writing @byrow multiple times when performing multiple transformations by row, @select! allows @byrow at the beginning of a block of select!ations (i.e. @byrow begin... end). All transformations in the block will operate by row.\n\nTransformations can also use the macro-flag @astable for creating multiple new columns at once and letting transformations share the same name-space. See ? @astable for more details.\n\nIn operations, it is also allowed to use AsTable(cols) to work with multiple columns at once, where the columns are grouped together in a NamedTuple. When AsTable(cols) appears in a operation, no other columns may be referenced in the block.\n\nUsing AsTable in this way is useful for working with many columns at once programmatically. For example, to compute the row-wise sum of the columns [:a, :b, :c, :d], write\n\n@byrow :c = sum(AsTable([:a, :b, :c, :d]))\n\nThis constructs the pairs\n\nAsTable(nms) => ByRow(sum) => :c\n\nAsTable on the right-hand side also allows the use of the special column selectors Not, Between, and regular expressions. For example, to calculate the product of all the columns beginning with the letter \"a\", write\n\n@byrow :d = prod(AsTable(r\"^a\"))\n\nExamples\n\njulia> using DataFrames, DataFramesMeta\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> df2 = @select!(df, :c, :a)\n8×2 DataFrame\n Row │ c      a\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      1\n   6 │     6      2\n   7 │     7      3\n   8 │     8      4\n\njulia> df === df2\ntrue\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> df2 = @select! df begin\n           :c\n           :x = :b + :c\n       end\n8×2 DataFrame\n Row │ c      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      3\n   3 │     3      5\n   4 │     4      5\n   5 │     5      7\n   6 │     6      7\n   7 │     7      9\n   8 │     8      9\n\njulia> df === df2\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@select-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@select","text":"@select(d, e...)\n\nSelect and transform columns.\n\nArguments\n\nd : an AbstractDataFrame or GroupedDataFrame\ne :  keyword-like arguments, of the form :y = f(:x) specifying\n\nnew columns in terms of existing columns or symbols to specify existing columns\n\nReturns\n\n::AbstractDataFrame\n\nInputs to @select can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation or selector, or as a series of arguments and keyword-like arguments arguments. For example, the following are equivalent:\n\n@select df begin\n    :x\n    :y = :a .+ :b\nend\n\nand\n\n@select(df, :x, :y = :a .+ :b)\n\n@select uses the syntax @byrow to wrap transformations in the ByRow function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call\n\n@select(df, @byrow :y = :x == 1 ? true : false)\n\nbecomes\n\nselect(df, :x => ByRow(x -> x == 1 ? true : false) => :y)\n\na transformation which cannot be conveniently expressed using broadcasting.\n\nTo avoid writing @byrow multiple times when performing multiple transformations by row, @select allows @byrow at the beginning of a block of selectations (i.e. @byrow begin... end). All transformations in the block will operate by row.\n\nTransformations can also use the macro-flag @astable for creating multiple new columns at once and letting transformations share the same name-space. See ? @astable for more details.\n\nIn operations, it is also allowed to use AsTable(cols) to work with multiple columns at once, where the columns are grouped together in a NamedTuple. When AsTable(cols) appears in a operation, no other columns may be referenced in the block.\n\nUsing AsTable in this way is useful for working with many columns at once programmatically. For example, to compute the row-wise sum of the columns [:a, :b, :c, :d], write\n\n@byrow :c = sum(AsTable([:a, :b, :c, :d]))\n\nThis constructs the pairs\n\nAsTable(nms) => ByRow(sum) => :c\n\nAsTable on the right-hand side also allows the use of the special column selectors Not, Between, and regular expressions. For example, to calculate the product of all the columns beginning with the letter \"a\", write\n\n@byrow :d = prod(AsTable(r\"^a\"))\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> @select(df, :c, :a)\n8×2 DataFrame\n Row │ c      a\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      1\n   6 │     6      2\n   7 │     7      3\n   8 │     8      4\n\njulia> @select df begin\n           :c\n           :x = :b + :c\n       end\n8×2 DataFrame\n Row │ c      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      3\n   3 │     3      5\n   4 │     4      5\n   5 │     5      7\n   6 │     6      7\n   7 │     7      9\n   8 │     8      9\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@subset!-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@subset!","text":"@subset!(d, i...)\n\nSelect row subsets in AbstractDataFrames and GroupedDataFrames, mutating the underlying data-frame in-place.\n\nArguments\n\nd : an AbstractDataFrame or GroupedDataFrame\ni... : expression for selecting rows\n\nMultiple i expressions are \"and-ed\" together.\n\nIf given a GroupedDataFrame, @subset! applies transformations by group, and returns a fresh DataFrame containing the rows for which the generated values are all true.\n\nInputs to @subset! can come in two formats: a begin ... end block, in which case each line is a separate selector, or as multiple arguments. For example the following two statements are equivalent:\n\n@subset! df begin\n    :x .> 1\n    :y .< 2\nend\n\nand\n\n@subset!(df, :x .> 1, :y .< 2)\n\nnote: Note\n@subset! treats missing values as false when filtering rows. Unlike DataFrames.subset! and other Boolean operations with missing, @subset! will not error on missing values, and will only keep true values.\n\nIf an expression provided to @subset! begins with @byrow, operations are applied \"by row\" along the data frame. To avoid writing @byrow multiple times, @orderby also allows @byrowto be placed at the beginning of a block of operations. For example, the following two statements are equivalent.\n\n@subset! df @byrow begin\n    :x > 1\n    :y < 2\nend\n\nand\n\n@subset! df\n    @byrow :x > 1\n    @byrow :y < 2\nend\n\nIn operations, it is also allowed to use AsTable(cols) to work with multiple columns at once, where the columns are grouped together in a NamedTuple. When AsTable(cols) appears in a operation, no other columns may be referenced in the block.\n\nUsing AsTable in this way is useful for working with many columns at once programmatically. For example, to select rows where the sum of the columns :a, :b, and :c is greater than 5, write\n\n@byrow sum(AsTable([:a, :b, :c])) > 5\n\nThis constructs the pair\n\nAsTable([:a, :b, :c]) => ByRow(t -> sum(t) > 5)\n\nAsTable on the right-hand side also allows the use of the special column selectors Not, Between, and regular expressions. For example, to subset all rows where the product of all columns starting with \"a\", is greater than 5, write\n\n@byrow prod(AsTable(r\"^a\")) > 5\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> globalvar = [2, 1, 0];\n\njulia> @subset!(copy(df), :x .> 1)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     3      2\n\njulia> @subset!(copy(df), :x .> globalvar)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     3      2\n\njulia> @subset! copy(df) begin\n           :x .> globalvar\n           :y .== 3\n       end\n0×2 DataFrame\n\njulia> df = DataFrame(n = 1:20, x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1,\n                                    2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);\n\njulia> g = groupby(copy(df), :x);\n\njulia> @subset!(g, :n .> mean(:n))\n8×2 DataFrame\n Row │ n      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    12      1\n   2 │    13      1\n   3 │    15      2\n   4 │    16      2\n   5 │    17      3\n   6 │    18      1\n   7 │    19      1\n   8 │    20      2\n\njulia> g = groupby(copy(df), :x);\n\njulia> @subset! g begin\n           :n .> mean(:n)\n           :n .< 20\n       end\n7×2 DataFrame\n Row │ n      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    12      1\n   2 │    13      1\n   3 │    15      2\n   4 │    16      2\n   5 │    17      3\n   6 │    18      1\n   7 │    19      1\n\njulia> d = DataFrame(a = [1, 2, missing], b = [\"x\", \"y\", missing]);\n\njulia> @subset!(d, :a .== 1)\n1×2 DataFrame\n Row │ a       b\n     │ Int64?  String?\n─────┼─────────────────\n   1 │      1  x\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@subset-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@subset","text":"@subset(d, i...)\n\nSelect row subsets in AbstractDataFrames and GroupedDataFrames.\n\nArguments\n\nd : an AbstractDataFrame or GroupedDataFrame\ni... : expression for selecting rows\n\nMultiple i expressions are \"and-ed\" together.\n\nIf given a GroupedDataFrame, @subset applies transformations by group, and returns a fresh DataFrame containing the rows for which the generated values are all true.\n\nInputs to @subset can come in two formats: a begin ... end block, in which case each line is a separate selector, or as multiple arguments. For example the following two statements are equivalent:\n\n@subset df begin\n    :x .> 1\n    :y .< 2\nend\n\nand\n\n@subset(df, :x .> 1, :y .< 2)\n\nnote: Note\n@subset treats missing values as false when filtering rows. Unlike DataFrames.subset and other Boolean operations with missing, @subset will not error on missing values, and will only keep true values.\n\nIf an expression provided to @subset begins with @byrow, operations are applied \"by row\" along the data frame. To avoid writing @byrow multiple times, @orderby also allows @byrow to be placed at the beginning of a block of operations. For example, the following two statements are equivalent.\n\n@subset df @byrow begin\n    :x > 1\n    :y < 2\nend\n\nand\n\n@subset df\n    @byrow :x > 1\n    @byrow :y < 2\nend\n\nIn operations, it is also allowed to use AsTable(cols) to work with multiple columns at once, where the columns are grouped together in a NamedTuple. When AsTable(cols) appears in a operation, no other columns may be referenced in the block.\n\nUsing AsTable in this way is useful for working with many columns at once programmatically. For example, to select rows where the sum of the columns :a, :b, and :c is greater than 5, write\n\n@byrow sum(AsTable([:a, :b, :c])) > 5\n\nThis constructs the pair\n\nAsTable([:a, :b, :c]) => ByRow(t -> sum(t) > 5)\n\nAsTable on the right-hand side also allows the use of the special column selectors Not, Between, and regular expressions. For example, to subset all rows where the product of all columns starting with \"a\", is greater than 5, write\n\n@byrow prod(AsTable(r\"^a\")) > 5\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> globalvar = [2, 1, 0];\n\njulia> @subset(df, :x .> 1)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     3      2\n\njulia> @subset(df, :x .> globalvar)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     3      2\n\njulia> @subset df begin\n           :x .> globalvar\n           :y .== 3\n       end\n0×2 DataFrame\n\njulia> df = DataFrame(n = 1:20, x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1,\n                                    2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);\n\njulia> g = groupby(df, :x);\n\njulia> @subset(g, :n .> mean(:n))\n8×2 DataFrame\n Row │ n      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    12      1\n   2 │    13      1\n   3 │    15      2\n   4 │    16      2\n   5 │    17      3\n   6 │    18      1\n   7 │    19      1\n   8 │    20      2\n\njulia> @subset g begin\n           :n .> mean(:n)\n           :n .< 20\n       end\n7×2 DataFrame\n Row │ n      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    12      1\n   2 │    13      1\n   3 │    15      2\n   4 │    16      2\n   5 │    17      3\n   6 │    18      1\n   7 │    19      1\n\njulia> df = DataFrame(a = [1, 2, missing], b = [\"x\", \"y\", missing]);\n\njulia> @subset(df, :a .== 1)\n1×2 DataFrame\n Row │ a       b\n     │ Int64?  String?\n─────┼─────────────────\n   1 │      1  x\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@transform!-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@transform!","text":"@transform!(d, i...)\n\nMutate d inplace to add additional columns or keys based on keyword-like arguments and return it. No copies of existing columns are made.\n\nArguments\n\nd : an AbstractDataFrame, or GroupedDataFrame\ni... : keyword-like arguments, of the form :y = f(:x) defining\n\nnew columns or keys\n\nReturns\n\n::DataFrame\n\nInputs to @transform! can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation, (:y = f(:x)), or as a series of keyword-like arguments. For example, the following are equivalent:\n\n@transform! df begin\n    :a = :x\n    :b = :y\nend\n\nand\n\n@transform!(df, :a = :x, :b = :y)\n\n@transform! uses the syntax @byrow to wrap transform!ations in the ByRow function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call\n\n@transform!(df, @byrow :y = :x == 1 ? true : false)\n\nbecomes\n\ntransform!(df, :x => ByRow(x -> x == 1 ? true : false) => :y)\n\na transformation which cannot be conveniently expressed using broadcasting.\n\nTo avoid writing @byrow multiple times when performing multiple transform!ations by row, @transform! allows @byrow at the beginning of a block of transform!ations (i.e. @byrow begin... end). All transform!ations in the block will operate by row.\n\nTransformations can also use the macro-flag @astable for creating multiple new columns at once and letting transformations share the same name-space. See ? @astable for more details.\n\nIn operations, it is also allowed to use AsTable(cols) to work with multiple columns at once, where the columns are grouped together in a NamedTuple. When AsTable(cols) appears in a operation, no other columns may be referenced in the block.\n\nUsing AsTable in this way is useful for working with many columns at once programmatically. For example, to compute the row-wise sum of the columns [:a, :b, :c, :d], write\n\n@byrow :c = sum(AsTable([:a, :b, :c, :d]))\n\nThis constructs the pairs\n\nAsTable(nms) => ByRow(sum) => :c\n\nAsTable on the right-hand side also allows the use of the special column selectors Not, Between, and regular expressions. For example, to calculate the product of all the columns beginning with the letter \"a\", write\n\n@byrow :d = prod(AsTable(r\"^a\"))\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> df2 = @transform!(df, :a = 2 * :A, :x = :A .+ :B)\n3×4 DataFrame\n Row │ A      B      a      x\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      2      3\n   2 │     2      1      4      3\n   3 │     3      2      6      5\n\njulia> df === df2\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@transform-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@transform","text":"@transform(d, i...)\n\nAdd additional columns or keys based on keyword-like arguments.\n\nArguments\n\nd : an AbstractDataFrame, or GroupedDataFrame\ni... : keyword-like arguments defining new columns or keys, of the form :y = f(:x)\n\nReturns\n\n::AbstractDataFrame or ::GroupedDataFrame\n\nInputs to @transform can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation, (:y = f(:x)), or as a series of keyword-like arguments. For example, the following are equivalent:\n\n@transform df begin\n    :a = :x\n    :b = :y\nend\n\nand\n\n@transform(df, :a = :x, :b = :y)\n\n@transform uses the syntax @byrow to wrap transformations in the ByRow function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call\n\n@transform(df, @byrow :y = :x == 1 ? true : false)\n\nbecomes\n\ntransform(df, :x => ByRow(x -> x == 1 ? true : false) => :y)\n\na transformation which cannot be conveniently expressed using broadcasting.\n\nTo avoid writing @byrow multiple times when performing multiple transformations by row, @transform allows @byrow at the beginning of a block of transformations (i.e. @byrow begin... end). All transformations in the block will operate by row.\n\nTransformations can also use the macro-flag @astable for creating multiple new columns at once and letting transformations share the same name-space. See ? @astable for more details.\n\nIn operations, it is also allowed to use AsTable(cols) to work with multiple columns at once, where the columns are grouped together in a NamedTuple. When AsTable(cols) appears in a operation, no other columns may be referenced in the block.\n\nUsing AsTable in this way is useful for working with many columns at once programmatically. For example, to compute the row-wise sum of the columns [:a, :b, :c, :d], write\n\n@byrow :c = sum(AsTable([:a, :b, :c, :d]))\n\nThis constructs the pairs\n\nAsTable(nms) => ByRow(sum) => :c\n\nAsTable on the right-hand side also allows the use of the special column selectors Not, Between, and regular expressions. For example, to calculate the product of all the columns beginning with the letter \"a\", write\n\n@byrow :d = prod(AsTable(r\"^a\"))\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> @transform df begin\n           :a = 2 * :A\n           :x = :A .+ :B\n       end\n3×4 DataFrame\n Row │ A      B      a      x\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      2      3\n   2 │     2      1      4      3\n   3 │     3      2      6      5\n\njulia> @transform df @byrow :z = :A * :B\n3×3 DataFrame\n Row │ A      B      z\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      2\n   2 │     2      1      2\n   3 │     3      2      6\n\njulia> @transform df @byrow begin\n           :x = :A * :B\n           :y = :A == 1 ? 100 : 200\n       end\n3×4 DataFrame\n Row │ A      B      x      y\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      2    100\n   2 │     2      1      2    200\n   3 │     3      2      6    200\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@where-Tuple{Any, Vararg{Any}}","page":"API","title":"DataFramesMeta.@where","text":"@subset(x, args...)\n\nDeprecated version of @subset, see ?@subset for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@with-Tuple{Any, Any}","page":"API","title":"DataFramesMeta.@with","text":"@with(d, expr)\n\n@with allows DataFrame columns keys to be referenced as symbols.\n\nArguments\n\nd : an AbstractDataFrame type\nexpr : the expression to evaluate in d\n\nDetails\n\n@with works by parsing the expression body for all columns indicated by symbols (e.g. :colA). Then, a function is created that wraps the body and passes the columns as function arguments. This function is then called. Operations are efficient because:\n\nA pseudo-anonymous function is defined, so types are stable.\nColumns are passed as references, eliminating DataFrame indexing.\n\nThe following\n\n@with(d, :a .+ :b .+ 1)\n\nbecomes\n\ntempfun(a, b) = a .+ b .+ 1\ntempfun(d[!, :a], d[!, :b])\n\nIf an expression is wrapped in ^(expr), expr gets passed through untouched. If an expression is wrapped in  $(expr), the column is referenced by the variable expr rather than a symbol.\n\nIf the expression provide to @with begins with @byrow, the function created by the @with block is broadcasted along the columns of the data frame.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> y = 3;\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> x = [2, 1, 0];\n\njulia> @with(df, :y .+ 1)\n3-element Vector{Int64}:\n 3\n 2\n 3\n\njulia> @with(df, :x + x)\n3-element Vector{Int64}:\n 3\n 3\n 3\n\njulia> @with df begin\n            res = 0.0\n            for i in 1:length(:x)\n                res += :x[i] * :y[i]\n            end\n            res\n        end\n10.0\n\njulia> @with(df, df[:x .> 1, ^(:y)]) # The ^ means leave the :y alone\n2-element Vector{Int64}:\n 1\n 2\n\njulia> colref = :x;\n\njulia> @with(df, :y + $colref) # Equivalent to df[!, :y] + df[!, colref]\n3-element Vector{Int64}:\n 3\n 3\n 5\n\njulia> @with df @byrow :x * :y\n3-element Vector{Int64}:\n 2\n 2\n 6\n\n\nnote: Note\n@with creates a function, so the scope within @with is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the global keyword. If the parent scope is a local scope (inside a function or let block for example), the global keyword is not needed to assign to that parent scope.\n\nnote: Note\nUsing AsTable inside @with block is currently not supported.\n\n\n\n\n\n","category":"macro"}]
}
